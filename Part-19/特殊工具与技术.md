# 特殊工具与技术

## 控制内存分配

### 重载new和delete

首先要对`new`表达式和`delete`表达式的工作机理有更多了解。

使用`new`表达式时：

```cpp
// new表达式
string *sp = new string("a value");			// 分配并初始化一个string对象
string *arr = new string[10];				// 分配10个默认初始化的string对象
```

实际执行步骤：

1. `new`表达式分配一个名为`operator new`(或者`operator new[]`)的标准库函数。该函数分配一块足够大、原始、未命名的内存空间以便存储特定类型的对象(或对象的数组)。
2. 编译器运行相应的构造函数以构造这些对象，并为其传入初始值。
3. 对象被分配了空间并构造完成，返回一个执行该对象的指针。

使用`delete`表达式时：

```cpp
delete sp;				// 销毁*sp 然后释放sp指向的内存空间
delete [] arr;			// 销毁数组中的元素 然后释放对应的内存空间
```

实际执行步骤：

1. 对`sp`所指的对象或`arr`所指的数组中的元素执行对应的析构函数
2. 编译器调用名为`operator delete`(或者`operator delete[]`)的标准库函数释放内存空间。

当自定义了全局的`operator new`函数和`operator delete`函数后，我们就担负起了控制动态内存分配的职责。

`operator new`和`operator delete`可以在全局作用域里定义，也可以定义为成员函数。编译器发现一条`new`或`delete`后，就会在程序里找可供调用的`operator`函数，如果是类类型，就会现在类及其基类的作用域里找。

可以用作用域运算符调用特定的版本，比如全局就是`::new`。

#### operator new接口和operator delete接口

标准库定义了`operator new`函数和`operator delete`函数的8个重载版本。前4个可能抛出`bad_alloc`异常，后4个不会抛出异常：

```cpp
// 可能抛出异常
void *operator new(size_t);						// 分配一个对象
void *operator new[](size_t);					// 分配一个数组
void *operator delete(void*) noexcept;			// 分配一个对象
void *operator delete[](void*) noexcept;		// 分配一个数组

// 承诺不会抛出异常
void *operator new(size_t, nothrow_t&) noexcept;
void *operator new[](size_t, nothrow_t&) noexcept;
void *operator delete(void*, nothrow_t&) noexcept;
void *operator delete[](void*, nothrow_t&) noexcept;
```

`nothrow_t`是定义在`new`头文件里的一个`struct`，该类不包含任何成员。`new`头文件还定义了一个名为`nothrow`的`const`对象，用户可以通过该对象请求`new`的非抛出异常版本。

类似析构函数，`opeator delete`也不允许抛出异常。重载它们时，必须使用`noexcept`异常说明符指定其不抛出异常。

将上述运算符定义为类成员时，它们时隐式静态的，但我们无须显式声明`static`(声明也不会报错)。因为`new`用在对象构造前，`delete`用在对象销毁后，所以它们必须是静态的，且不能操纵类的任何数据成员。

`operator new`和`operator new[]`函数：

- 返回类型必须是`void*`
- 第一个形参类型必须是`size_t`，不能有默认实参

编译器为对象分配内存空间：

- 使用函数：`operator new`
- 把存储指定类型对象所需的字节数传给`size_t`形参 

编译器为数组分配内存空间：

- 使用函数：`operator new[]`
- 把存储数组里所有元素所需的空间传给`size_t`形参

若想自定义`new`，可以给它传递额外形参。此时用到这些自定义函数的`new`表达式必须使用`new`的定位形式。将实参传给新增的形参。

下面这个函数不能被用户重载：

```cpp
void *operator new(size_t, void*);
```

这种形式只供标准库使用，不可被重定义。

对于`operator delete`和`operator delete[]`：

- 返回类型必须是`void`
- 第一个形参类型必须是`void*`

执行一条`delete`表达式将调用相应的`operator`函数，并用指向待释放内存的指针来初始化`void*`形参。

如果把`operator delete`或`operator delete[]`定义成类的成员时，该函数可以包含另一个类型为`size_t`的形参。此时，该形参的初始值是第一个形参所指对象的字节数。`size_t`形参可以用于删除继承体系里的对象。如果基类有个虚析构函数，那么传递给`operator delete`的字节数会因待删除指针所指对象的动态类型不同而有所区别。而且，实际运行的`operator delete`函数版本也由对象的动态类型决定。

我们提供新的`oeprator new`和`operator delete`的目的在于改变内存分配的方式，但我们不能改变`new`运算符和`delete`运算符的基本含义。

实际上根本无法自定义`new`和`delete`，`new`的执行过程总是先调用`operator new`函数以获取内存空间，然后在得到的内存空间里面构造对象。而`delete`则先销毁对象，然后再调用`operator delete`函数释放对象所占的空间。

#### malloc函数和free函数

`malloc`和`free`继承自C，定义在`cstdlib`头文件中。

`malloc`接受一个表示待分配字节数的`size_t`，返回指向分配空间的指针或者返回`0`以表示分配失败。

`free`接受一个`void*`，是`malloc`返回的指针的副本，`free`将相关内存返回给系统。调用`free(0)`没有任何意义。

```cpp
void *operator new(size_t size) {
    if (void *mem = malloc(size))
		return mem;
    else
        throw bad_alloc();
}

void operator delete(void* mem) noexcept {
    free(mem);
}
```

### 定位new表达式

对于`operator new`分配的内存空间来说，我们无法使用`construct`函数构造对象。而是应该用`new`的**定位new**(placement new)形式构造对象。

可以用定位`new`传递一个地址：

```cpp
new (place_address) type
new (place_address) type (initializers)
new (place_address) type [size]
new (place_address) type [size] { braced initializer list }
```

其中`place_address`必须是个指针，同时在`initializers`中提供一个(可能为空)以逗号分隔的初始值列表，该初始值列表将用于构造新分配的对象。

当通过一个地址值调用时，定位`new`使用`operator new(size_t, void*)`"分配"它的内存。该函数不分配任何内存，只是简单地返回指针实参；然后由`new`表达式负责在指定的地址初始化对象以完成整个工作。

定位`new`允许我们在一个特定的、预先分配的内存地址上构造对象。

当只传入一个指针类型的实参时，定位`new`表达式构造对象但是不分配内存。

尽管在很多时候使用定位`new`与`allocator`的`construct`成员非常相似，但在它们间也有个重要的区别：传给`construct`的指针必须指向同一个`allocator`对象分配的空间，但是传给定位`new`的指针无须指向`operator new`分配的内存。

#### 显式的析构函数调用

通过对象的指针或引用调用析构函数与其它成员函数没有区别：

```cpp
string *sp = new string("a value");			// 分配并初始化一个string对象
sp->~string();
```

调用析构函数会销毁对象，但是不会释放内存。如果需要，可以重新使用该空间。

## 运行时类型识别

**运行时类型识别**(run-time type identification, RTTI)的功能由两个运算符实现：

- `typeid`运算符，用于返回表达式的类型
- `dynamic_cast`运算符，用于将基类的指针或引用安全地转换成派生类地指针或引用

如果把这两个运算符用于指针或引用，且该类型含有虚函数时，运算符将使用指针或引用所绑定对象的动态类型。

这两个运算符特别适用于这种情况：当想使用基类对象的指针或引用执行某个派生类操作且该操作不是虚函数。

但是不是什么时候都能定义虚函数。如果无法使用虚函数，那么就可以用RTTI运算符。

与虚成员函数相比，RTTI运算符有更多潜在的风险：程序员必须清楚知道转换的目标类型并且必须检查类型转换是否被成功执行。

在可能的情况下，最好定义虚函数，而不是直接接管类型管理的重任。

### dynamic_cast运算符

**dynamic_cast运算符**(dynamic_cast operator)的使用形式如下所示：

```cpp
dynamic_cast<type*>(e)			// e必须是个有效指针
dynamic_cast<type&>(e)			// e必须是个左值
dynamic_cast<type&&>(e)			// e不能是左值
```

`type`必须是个类类型，且通常情况下应该有虚函数。

`e`必须符合下述条件中任意一个：

1. `e`的类型是目标`type`的公有派生类
2. `e`的类型是目标`type`的公有基类
3. `e`的类型是目标`type`的类型

- 若符合，则类型转换成功
- 否则，转换失败。如果转换目标是指针类型，那么结果是`0`；如果转换目标是引用类型，那么会由`dynamic_cast`运算符抛出一个`bad_cast`异常。

#### 指针类型的dynamic_cast

假定`Base`类有个虚函数，`Derived`是`Base`的公有派生类。

若有个指向`Base`的指针`bp`，则我们能在运行时将它转成指向`Dervied`的指针：

```cpp
if (Dervied *dp = dynamic_cast<Derived*>(bp)){
    // 使用dp指向的Derived对象
} else {
    // 使用bp指向的Base对象
}
```

可以对一个空指针执行`dynamic_cast`，结果是所需类型的空指针。

在条件部分执行`dynamic_cast`操作可以确保类型转换和结果检查在同一条表达式中完成。

#### 引用类型的dynamic_cast

因为不存在空引用，所以对于引用类型而言，无法使用与指针类型完全相同的错误报告策略。

当对引用的类型转换失败时候，程序抛出名为`std::bad_cast`的异常，该异常定义在`typeinfo`标准库头文件中：

```cpp
void f(const Base &b)
{
    try {
        const Derived &d = dynamic_cast<const Derived&>(b);
        // 使用b引用的Derived对象
    } catch (bad_cast) {
        // 处理类型转换失败的情况
    }
}
```

### typeid运算符

**typeid运算符**(typeid operator)。

`typeid(e)`：

- `e`：任意表达式或类型名
- 结果：常量对象的引用。该对象的类型是`type_info`或`type_info`的公有派生类型。

`type_info`定义在`typeinfo`头文件里。

若表达式是个引用，则`typeid`返回该引用所引对象的类型。不过当`typeid`作用于数组或函数时，不会指向向指针的标准类型转换。

也就是对数组`a`执行`typeid(a)`，所得结果为数组类型而非指针类型。

- 当运算对象不属于类类型或是一个不包含任何虚函数的类时，`typeid`运算符指示的是运算对象的静态类型。
- 当运算对象是定义了至少一个虚函数的类的左值时，`typeid`的结果直到运行时才求得。

#### 使用typeid运算符

通常用`typeid`比较两条表达式的类型是否相同，或者比较一条表达式的类型是否与指定类型相同：

```cpp
Derived *dp = new Derived;
Base *bp = dp;					// 两个指针都指向Derived对象
// 运行时比较两个对象类型
if (typeid(*bp) == typeid(*dp)) {
	// bp和dp指向同一类型
}

// 检查运行时类型是否时某种指定的类型
if (typeid(*bp) == typeid(Derived)) {
    // bp实际指向Derived对象
}
```

`typeid`应该作用于对象，所以是`*bp`，而不是`bp`。

如果`typeid`作用于指针(而非指针所指对象)。那么返回的结果是该指针的静态编译时类型。

`typeid`是否需要运行时检查 决定了表达式是否会被求值。只有在类型含有虚函数的时候，编译器才会对表达式求值。

也就是说，如果表达式的动态类型可能于静态类型不同，那么就必须要在运行时对表达式求值来确定返回的类型。

对于`typeid(*p)`，如果`p`是个空指针，那么`typeid(*p)`会抛出一个名为`bad_typeid`的异常。

### 使用RTTI

例如当我们想给具有继承关系的类实现相等运算符时候，RTTI非常有用。

派生类的相等运算符需要考虑派生类的新成员。

需要清楚一个事实：如比较对象类型不同，则比较结果为`false`。也就是如果对基类对象和派生类使用`==`，那么应返回`false`。

基于该事务，相等运算符的形参是基类的引用，然后使用`typeid`检查两个运算对象的类型是否一致。若运算对象的类型不同，则`false`；类型一致，则去比较它们的成员。

对于类型一致的，可以定义一个虚函数`equal`，接收一个基类的引用，取比较它们的成员。

#### 类的层次关系

```cpp
class Base {
    friend bool operator==(const Base&, const Base&);
public:
    // Base的接口成员
private:
    virtual bool equal(const Base&) const;
    // Base的数据成员和其它用于实现的成员
};

class Derived: public Base {
public:
    // Derived的其它接口成员
protected:
    bool equal(const Base&) const;
    // Derived的数据成员和其它用于实现的成员
};
```

#### 类型敏感的相等运算符

```cpp
bool operator==(const Base &lhs, const Base &rhs)
{
    // 若typeid不同 返回false 否则虚调用equal
    return typeid(lhs) == typeid(rhs) && lhs.equal(rhs);
}
```

#### 虚equal函数

继承体系的每个类都定义自己的`equal`函数。

```cpp
bool Derived::equal(const Base &rhs) const
{
    // 我们清楚这两个类型是相等的 所以转换过程不会抛出异常
    auto r = dynamic_cast<const Derived&>(rhs);
 
    // 执行比较两个Derived对象的操作并返回结果
}
```

#### 基类equal函数

```cpp
bool Base::equal(const Base &rhs) const 
{
    // 执行比较Base对象的操作
}
```

### type_info类

**type_info**类的精确定义随着编译器的不同而略有差异。但C++标准规定`type_info`类必须定义在`typeinfo`头文件中，且至少提供下表所示操作：

![image-20210421153034609](.assets/image-20210421153034609.png)

因为`type_info`通常作为一个基类出现，所以它还应该提供一个公有的虚析构函数。当编译器希望提供额外的类型信息时，通常在`type_info`的派生类里完成。

`type_info`类没有默认构造函数，并且拷贝构造函数和移动构造函数都被定义为删除，所以不能定义或者拷贝`type_info`的对象，也不能为`type_info`类型的对象赋值。

创建`type_info`对象的唯一方式是用`typeid`运算符。

对于`t.name()`的返回值的唯一要求是，类型不同则返回的字符串必须有所区别：

```cpp
int arr[10];
Derived d;
Base *p = &d;

cout << typeid(42).name() << ", "
     << typeid(arr).name() << ", "
     << typeid(Sales_data).name() << ", "
     << typeid(std::string).name() << ", "
     << typeid(p).name() << ", "
     << typeid(p).name() << endl;
```

书作者的计算机上返回如下：

![image-20210421153724840](.assets/image-20210421153724840.png)

有的编译器提供了额外的成员函数以提供程序中所用类型的额外信息。

## 枚举类型

