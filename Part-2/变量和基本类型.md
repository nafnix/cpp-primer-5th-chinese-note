# 变量和基本类型

## 基本内置类型

### 算术类型

算术类型分为两类：**整型**(integral type，包括字符和布尔类型在内)和**浮点型**。

算术类型的尺寸(该类型 数据所占的比特数)在不同机器上有所差别。

| 类型          | 含义           | 最小尺寸     |
| ------------- | -------------- | ------------ |
| `bool`        | 布尔类型       | 未定义       |
| `char`        | 字符           | 8位          |
| `wchar_t`     | 宽字符         | 16位         |
| `char16_t`    | Unicode字符    | 16位         |
| `char32_t`    | Unicode字符    | 32位         |
| `short`       | 短整型         | 16位         |
| `int`         | 整型           | 16位         |
| `long`        | 长整型         | 32位         |
| `long long `  | 长整型         | 64位         |
| `float`       | 单精度浮点数   | 6位有效数字  |
| `double`      | 双精度         | 10位有效数字 |
| `long double` | 扩展精度浮点数 | 10位有效数字 |

一个`char`的空间应确保可以存放机器基本字符集中任意字符对应的数字值。也就是说一个`char`的大小和一个机器字节一样。

其他字符类型用于扩展字符集，如`wchar_t`、`char16_t`、`char32_t`。`wchar_t`类型用于确保可以存放机器最大扩展字符集中的任意一个字符，类型`char16_t`和`char32_t`则为Unicode字符集服务。

对于数字类型，C++规定如下，其中左边的尺寸最小都等于后者的最大尺寸

- int>=short
- long>=int
- long long>=long

long long是在C++11中新定义的

> #### 内置类型的机器实现。
>
> 计算机以比特序列存储数据，每个比特非0即1。
>
> 大多数计算机以2的整数次幂个比特作为块来处理内存，可以寻址的最小内存块称为**字节(byte)**，存储的基本单元称为**字(word)**，他们通常由几个字节组成(字)。大多数的字节由8比特过程，字则由32或64比特构成，也就是4或8字节。
>
> 大多数计算机将内存中的每个字节与一个数字(被称为地址(address))关联起来，例如在一个字节位8比特，字为32比特的机器上，我们可能看到一个字的内存区域如下所示
>
> | 字节地址 | 具体内容 |
> | -------- | -------- |
> | 736424   | 00111011 |
> | 736425   | 00011011 |
> | 736426   | 01110001 |
> | 736427   | 01100100 |
>
> 我们能够使用某个地址来表示从这个地址开始的大小不同的比特串。例如我们可能会说地址736424的那个字或者地址736427的那个字节。为了赋予内存中某个地址明确的含义，必须首先知道存储在该地址的数据的类型。类型决定了数据所占的比特数以及该如何解释这些比特的内容。
>
> 如果为止736424处的对象类型是float，并且该机器中float以32比特存储，那么我们就能知道这个对象的内容沾满了整个字。这个float数的实际值依赖于该机器是怎么存储浮点数的。

浮点数可以表示单精度、双精度和扩展精度值。C++标准指定了一个浮点数有效位数的最小值，然而大多数编译器都实现了更高的精度。通常，float以1个字(32比特)来表示，double以2个字(64比特)来表示，long double以3或4个字来表示。一般，类型float和double分别有7和16个有效位；类型long double则常常被用于有特殊浮点需求的硬件，它的具体实现方式不同，精度也各不相同。

#### 带符号类型和无符号类型

除布尔和扩展的字符型以外，其他整型可以划分为**带符号的(signed)和无符号的(unsigned)**两种。带符号类型可以表示正数、负数、0。无符号类型仅能表示大于等于0的值。

`int`、`short`、`long`、`long long `都是带符号的，但是在他们类型前加`unsigned`就可以将其转为无符号类型。如`unsigned long`。而`unsigned int`可以直接写为`unsigned`。

字符型被分为三种：`char`、`signed char`、`unsigned char`。`char`和`signed char`不一样。

字符只有两种表现形式：带符号的、无符号的。而`char`到底是哪种由编译器决定。

无符号类型的所有比特都用于存储值，例如，8比特的`unsigned char`可以表示0到255区间的值。

C++没有规定带符号类型怎么表示，但是约定了在表示范围内正值和负值的量应个均衡。因此，8比特的`signed char`理论上可以表示-127到127区间的值，大多现代计算机将实际的表示范围定为-128到127。

#### 如何选择类型

- 当明确知晓数值不可能为负时，选用无符号类型
- 使用`int`执行整数运算。如果超了就用`long long`。`short`太小，`long`跟`int`一般尺寸一样。
- 在算术表达式中不要使用`char`和`bool`，只有存放字符或者布尔值时候才用他们。因为char在一些机器上有符号再另一些机器上时无符号，如果使用char进行运算就容易出事。如果需要使用一个不大的整数，那么明确指定它的类型是有符号或者无符号。
- 执行浮点数运算用`double`。通常`float`精度不够，但是单精度跟双精度的计算代价相差无几。甚至有些机器上双精度比单精度还快。

### 类型转换

对象的类型定义了对象能包含的数据和能参与的运算，其中一种运算被大多数类型支持，就是将对象从一种给定的类型**转换**(conver)为另一种相关类型。

```cpp
bool b = 42;            // b为真(1)
int i = b;                // i的值为1
i = 3.14;                // i的值为3
double pi = i;            // pi的值为3.0
unsigned char c = -1;    // 假设char占8比特，c的值为255
signed char c2 = 256;    // 假设char占8比特，c2的值是未定义的
```

- 当把一个非布尔类型的算术值赋给布尔类型时候，初始值是0那结果就是false，否则可以说都是true。
- 若把一个布尔值赋给非布尔类型时，初始值为false则结果就是0，否则就是true。
- 当把一个浮点数赋给整数类型时，进行了近似处理。结果值只保留小数前的部分。
- 当把一个整数值赋给浮点类型时，小数部分记成0。如果该整数所占的空间超过了浮点类型的容量，精度可能损失。
- 当我们赋给带符号类型一个超出它表示范围的值时，结果是**未定义的**(uncdefined)。此时，程序可能继续工作、可能崩溃，也可能产生乐色数据。

- 当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。例如8比特大小的`unsigned char`可能表示0至255间的额值，如果我们赋了一个0至255之外的值，则实际的结果是该值对256取模后所得的余数。因此，把`-1`赋给8比特大小的`unsigned char`所得的结果是255。也说明如果取模后的值是0，那么再将此值赋给布尔类型那么布尔类型也会得到false，虽然看着不是0但是就是0。

**我们要避免依赖实现环境和无法预知的行为，如不可移植的程序**

#### 含有无符号类型的表达式

```cpp
unsigned u = 10;
int i = -42;
std::cout << i + i << std::endl;        // -84
std::cout << u + i << std::endl;        // 如果int占32位，输出4294967264
 
unsigned u1 = 42, i = 10;
std::cout << i - u1 << std::endl;        // 4294967264
 
// 错误的for循环
for (int i = 10; i >= 0; --i)
    std::cout << i << std::endl;        // 由于无符号类型i永远不可能为负数，所以导致死循环
// 修复for循环的方法
for (unsigned i = 10; i > 0; --i)
    std::cout << i << std::endl;
```

**不要混用带符号类型和无符号类型**

### 字面值常量

如`42`，是**字面值常量**

#### 整型和浮点型字面值

| 十进制 | 八进制 | 十六进制 |
| ------ | ------ | -------- |
| 20     | 024    | 0x14     |

默认十进制是带符号数，八进制和十六进制可能是带符号也能是无符号。

十进制字面值的类型是`int`、`long`、`long long`中尺寸最小的那个

八进制和十六进制字面值类型是`int`、`unsigned`、`long`、`unsigned long`、`long long`、`unsigned long long`中尺寸最小的那个

严格而言，十进制字面值不会是负数。如果使用`-42`，事实上`-`并不在字面值当中，它的作用是对字面值取负值。

浮点型字面值表现为小数或者科学计数法表示的指数，其中指数部分用E或e标识。

`3.14159`、`3.14159E0`、`0.`、`0e0`、`.001`

默认浮点型字面值是double类型，也就是上面几个包括`0.`都是double类型

#### 字符和字符串字面值

```cpp
'a'                // 字符字面值
"Hello World!"    // 字符串字面值
```

字符串字面值的类型实际上是由常量字符构成的**数组**(array)。

编译器会在每个字符串的末尾处添加一个空字符`'\0'`，因此，字符串字面值的实际长度要比它的内容多1。

```cpp
'a'                // 'a'
"a"                // "a\0"
"Hello World!"    // "Hello World!\0"
```

如果两个字符串字面值位置紧凑且仅由空格、换行符、缩进分隔，则它们实际上是一个整体。

```cpp
std::cout << "第一行"
             "第二行" << std::endl;
//实际上是数组
```

#### 转义序列

有两种字符不能直接用

1. **不可打印**(nonprintable)的字符
   - 如退格或者其他控制字符，因为它们没有可视的图符
2. C++中有特殊含义的字符
   - 如引号、分号

想要使用含有特殊含义的字符需要使用**转义序列**(escape sequence)

C++规定的转义序列：

| 可用的转义序列 | 含义       |
| -------------- | ---------- |
| `\n`           | 换行符     |
| `\t`           | 横向制表符 |
| `\a`           | 报警符     |
| `\v`           | 纵向制表符 |
| `\b`           | 退格符     |
| `\"`           | 双引号     |
| `\'`           | 单引号     |
| `\\`           | 反斜线     |
| `\?`           | 问好       |
| `\r`           | 回车符     |
| `\f`           | 进纸符     |

```cpp
// 使用示例
std::cout << "换行符号->\n" << "\t<-制表符 换行符->\n" << std::endl;
```

部分泛化转义序列

| 泛化转义序列 | 含义      |
| ------------ | --------- |
| `\7`         | 响铃      |
| `\12`        | 换行符    |
| `\40`        | 空格      |
| `\0`         | 空字符    |
| `\115`       | 字符M     |
| `\x4d`       | 也是字符M |

```cpp
// 使用示例
std::cout<< "换行符->\12" >> "泛化转义序列字符M-> \x4d -> \\115" << std::endl;
```

#### 指定字面值的类型

字符和字符串字面值：

| 前缀 | 含义                        | 类型     |
| ---- | --------------------------- | -------- |
| u    | Unicode16字符               | char16_t |
| U    | Unicode32字符               | char32_t |
| L    | 宽字符                      | wchar_t  |
| u8   | UTF-8(仅用于字符串字面常量) | char     |

整形字面值：

| 后缀(大小写皆可) | 最小匹配类型 |
| ---------------- | ------------ |
| U                | unsigned     |
| L                | long         |
| LL               | longlong     |

浮点型字面值：

| 后缀(大小写皆可) | 类型        |
| ---------------- | ----------- |
| F                | float       |
| L                | long double |

```cpp
// 使用示例
L'a'            // 宽字符型字面值，wchar_t类型
u8"hi!"            // utf-8字符型字面值 (utf-8用8位编码一个Unicode字符)
42ULL            // unsigned long long
1E-3F            // 单精度浮点型，1E(-3)F
// 1E (-3) F         F(Float)类型的 1E(-3) ，1E(-3) == 1 * -1000
3.14159L        // long double
```

#### 布尔字面值和指针字面值

`true`和`false`是布尔类型的字面值

```cpp
bool test = false
```

## 变量

变量提供一个具名(有名字)的、可以给程序操作(做牛做马)的存储空间。C++每个变量都有其数据类型，数据类型决定着变量所占内存空间的大小和布局方式、所在空间能存储的值的范围，以及变量能参与的运算。

对C++码农来说，变量(variable)和对象(object)一般可以互换使用。

### 变量定义

```cpp
// 定义
类型说明符 变量名(若有多个就用,隔开);
 
// 定义时顺便赋初始值
类型说明符 变量名1 = 值1, 变量名2 = 值2, ... ;
```

```cpp
// 定义示例
int v;
int sum, value;
Sales_item item;
 
// 定义并赋初始值
bool really = true;
int sum = 0, value = 1;
```

也可以使用库类型定义

```cpp
#include <string>
std::string book_name("《C++ Primer》");
```

`book_name`通过一个string字面值初始化

`string`也是在命名空间中定义的。了解`string`是一种 表示可变长字符序列 的数据类型即可。

实例中`book_name`被初始化成了`"《C++ Primer》"`

#### 啥是对象？

常指一块能存储数据并具有某种类型的内存空间。

即能放东西的并且属于某个类的内存空间。

#### 初始值

当对象在创建时候获得一个特定的值，即这个对象被**初始化**(initialized)。用于初始化变量的值可以时任意复杂的表达式。

```cpp
double price = 10.1, price_2_value = price * 2;
```

**初始化不是赋值！初始化含义是创建变量时候赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值替代。**

初始化是第一次装饭，赋值是把原来的饭倒掉再装一碗。

#### 列表初始化

C++11新添允许使用花括号初始化变量，在11之前这种初始化的形式只在某些受限场合下可以用。

这种初始化方式称之为**列表初始化**(list initialization)。

```c++
int ze = 0;
int ze{0};
int ze = {0};
int ze(0);            // 使用圆括号也可以
```

用于内置类型的变量时候，如果用这种方式并且初始值存在丢失信息的风险，编译器就会报错：

```cpp
long double ld = 3.1415926536;
int a{ld}, b = {ld};        // 错误，转换不执行，因为可能丢数据
int c(ld), d = ld;            // 正确，转换执行，但也丢了部分值
// 不理解的话别用就好
```

#### 默认初始化

如果定义时没指定初始值，则变量被**默认初始化**(default initialized)，此时变量被赋予了"默认值"。默认值由变量类型决定是什么，定义变量的位置也会对默认值有影响。

定义在任何函数体外的变量会被初始化为0。

有种例外是，定义在函数体内部的内置类型变量会**不被初始化**(uninitialized)。一个没有被初始化的内置类型变量的值是没有定义的，如果试图拷贝或者以其他形式访问此类值就会出错。

大多数类都支持无须显示初始化而定义对象，这样的类提供了一个合适的默认值。例如`string`类规定如果没有指定初始值就生成一个空字符串。

```cpp
std::string empty;        // enpty非显示初始化为一个空串
Sales_item item;        // 被默认初始化的Sales_item对象
```

有些类会要求每个对象都显式初始化，如果使用这些类时候没有初始化就会报错。

> **定义在函数体内的内置类型的对象如果没有初始化，则其值没有定义。类的对象如果没有显示地初始化，则其值由类确定。**

即如果函数体里面使用如`int`这些的对象没有初始化，则它的值就没有定义(感觉像废话)。

如果我们再调用类的时候没有初始化，那么类的返回值就看创造该类的人是怎么决定的。

#### Other

```
std:cin >> int input_value;
double salary = wage = 9999.998
```

**建议每个变量都初始化。**

### 变量声明和定义的关系

C++支持分离式编译(separate compilation)机制，该机制允许程序把逻辑部分拆开编写，每个部分可以单独编译。

为了支持分离式编译，C++把声明和定义区分开来。**声明**(declaration)使得名字为程序知道，一个文件如果想用别的地方定义的名字就必须包含对那个名字的声明。而定义(definition)负责创建和名字关联的实体。

声明变量而不定义

```cpp
extern int i;    // 声明i而不定义i
```

在函数体里面试图初始化一个声明的变量，就会报错。

变量可以被多次声明，但是只能定义一次。

如果要在多个文件里用同一个变量，就必须分离声明和定义。且定义只能在一个文件中出现，而其他用到该变量的文件就必须对其声明，不能重复定义。

> ### 静态类型语言C++
>
> 指在编译阶段检查类型。检查类型的过程叫做**类型检查**(type checking)

### 标识符

C++的**标识符**(identifier)由

- 字母、数字和下划线组成。
- 必须以字母或者下划线开头。
- 标识符长度没有限制
- 大小写敏感
- 不能连续出现两个下划线
- 不能下划线接大字母开头
- 函数体外的标识符不能以下划线开头

#### 命名规范

1. 标识符能体现实际含义
2. 变量名一般用小写字母
3. 用户自定义的类名一般以大写字母开头，例如`Sales_item`
4. 如果标识符由多个单词组成，则单词间应有明显区分
5. 避免使用如`int`、`double`这类C++关键字(内置的变量名)

### 名字作用域

**作用域**(scope)是程序的一部分，在其中名字有其特定的含义。C++大多作用域以花括号`{}`分隔。

同一个名字在不同作用域可能指向不同的实体。名字有效范围局限于当前所在的`{}`之中

```cpp
#include <iostream>
 
int main()
{
    int out_block = 1;
    {
        int in_block = 0;
    }
    return 0;
}
 
```

对于`in_block`所在的作用域而言，定义在`main`主函数中的`out_block`是**全局作用域**(global scope)。全局作用域在整个程序的范围都能用。

而对于`out_block`所在的作用域而言，`in_block`是在**块作用域**(block scope)当中。在`out_block`所在的作用域不能访问到`int_block`的值。

其实for循环、while循环、if语句之中的内容也可以理解为处在作用于当中

#### 嵌套的作用域

作用域能嵌套作用域。对于作用域而言，作用域里的作用域是**内层作用域**(inner scope)。作用域里的作用域又觉得外面那个作用域是**外层作用域**(outer scope)。

```cpp
#include <iostream>
 
int outer_block = 0
 
int main()
{
    int out_block = 1;
    {
        int in_block = 2;
    }
    return 0;
}
 
```

`in_block`是**正在作用域内**(in scope)。

## 复合类型

**复合类型**(compound type)指基于其他类型定义的类型。C++语言有几种复合类型，例如引用和指针。

一条简单的声明语句更确切的说法应是：**基本数据类型**(base type)和紧随其后的一个**声明符**(declarator)组成。

### 引用

> C++新增了一种引用："右值引用(rvalue reference)"。这种引用主要用于内置类。严格而言，当我们说"引用(reference)"时候，指的是"左值引用(lvalue reference)"。

**引用**(reference)为对象起了另一个名字，引用类型引用(refers to)另一种类型。

引用与对象的数据类型必须一致。

```c++
int ival = 1024;
int &refVal = ival;            // refVal指向ival，也可以理解为refVal是ival的另一张身份证
int &refVal2;                // 错误写法
```

引用只能绑定在对象上，不能赋值

```cpp
int &refVal3 = 123;            // 错误，引用不能直接赋值
```

定义了一个引用之后，对其进行的操作都是在与之绑定的对象上进行的。

```cpp
#include <iostream>
 
int main()
{
    int i = 1;
    int &b = i;
    b = 2;
    std::cout<< i;            // 输出2
    return 0;
}
 
```

 

### 指针

**指针**(pointer)是"指向(point to)"另外一种类型的复合类型。指针与引用类似，也提供了对其他对象的间接访问。

- 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。
- 指针无须在定义时赋初值。

```cpp
// 定义指针示例
int *ip1, *ip2;
double dp, *dp2;
```

#### 获取对象的地址

指针存放某个对象的地址，要获取该地址需要使用**取地址符`&`**

```cpp
int ival = 42;
int *p = &ival;        // p存放变量ival的地址， p是指向变量ival的指针
```

除特定情况外，所有指针的类型都要和它所指向的对象完全相同。

```cpp
double dval;
double *pd = &dval;        // pd指针初始化取dval的地址
double *pd2 = pd;        // pd2指针初始化取double对象pd，而非指针pd的地址
```

#### 指针值

指针的值(地址)应属于下列4种状态之一

- 指向一个对象
- 指向紧邻对象所占空间的下一个位置
- 空指针，即不指向任何对象
- 无效指针，也就是上述情况外的其他值。

试图拷贝或者以其他方式访问无效指针的值都会引发错误。

第二种和第三种的指针虽然有效但是我们要避免使用。

#### 利用指针访问对象

如果指针指向一个对象，可以用**解引用符`*`**来访问对象。

```cpp
int ival = 42;
int *p = &ival;        // p存放ival的地址
std::cout << *p;
```

也可以通过解引用符给指针所指对象重新赋值

```cpp
int ival = 42;
int *p = &ival;        // p存放ival的地址
 
*p = 32;
std::cout << ival;
```

#### 空指针

**空指针**(null pointer)不指向任何对象，在试图使用一个指针之前代码可以首先检查它是否为空。

```c++
// 生成空指针示例
int *p1 = nullptr;        // 等价于int *p1 = 0;推荐，不过是C++11引入的
int *p2 = 0;              // 直接将p2初始化为字面常量0
 
// 需要先#include cstdlib
int *p3 = NULL;            // 等价于int *p3 = 0;
```

`nullptr`是特殊类型的字面值，可以转换成任意其他的指针类型。

过去的程序还会使用名为`NULL`的**预处理变量**(preprocessor variable)来给指针赋值，这个变量在头文件cstdlib中定义，它的值就是0。

预处理变量不属于命名空间std，它由预处理器负责管理，因此我们可以直接使用预处理变量而不用在前面加上`std::`。

将int变量直接赋值给指针是错误的操作，即使int变量的值正好是0也不行。

```cpp
int zero = 0;
pi = zero;        // 错误，不能把int变量直接赋给指针
```

- 使用未经初始化的指针是引发运行时错误的一大原因。
- 如果去访问没有初始化的指针，就相当于访问一个不存在的位置上的一个不存在的对象。
- 尽量在定义了对象后再定义指向它的指针。

#### 赋值和指针

引用本身不是对象。引用不可修改绑定对象。

给指针赋值就是将它存放在一个新的地址，使之指向另一个对象。

```cpp
#include <iostream>
 
int main()
{
    int i = 42;
    int *pi = 0;
    int *pi2 = &i;
    int *pi3;        // 可能是个无效指针，但是如果恰巧所在地址有东西就那就日了狗了
 
    pi3 = pi2;
    std::cout << *pi3 << std::endl;        // 42
    pi2 = 0;        // 不指向任何东西了
    std::cout << *pi3 << std::endl;        // 42
    return 0;
}
 
```

#### 其他指针操作

于if语句而言，若指针是一个空指针，或者为0，那么它就是false；除此之外任何非0的指针对于的条件值都是true。对于两个类型相同的合法指针，可以用相等操作符`==`或不相等操作符`!=`来比较它们，比较的结果是布尔类型。

#### void* 指针

**`void*`**是一种特殊的指针类型，可以用于存放任意对象(任意类型)的地址。有时候使用`void*`指针，指针所指向的值我们都不知道他是什么类型的。

```cpp
double obj = 3.14, *pd = &obj;
 
void *pv = &obj;
pv = pd;
```

利用`void*`指针能够做的事情比较有限：

- 将它和其他指针比较
- 作为函数的输入输出
- 赋给另一个`void*`指针

不能直接操作`void*`指针所指向的对象，因为我们不知道该对象是什么类型，也就无法确定能在这个对象上做什么事。

```cpp
#include <iostream>
 
int main()
{
    int i = 42;
    int *p1 = &i;        // 定义指针p1存放i的地址
    *p1 = *p1 * *p1;    // 解引用符将地址值重新赋值
    std::cout << i << std::endl;
    return 0;
}
 
```

### 理解符合类型的声明

类型修饰符(`*或者&`)是声明符的一部分

```cpp
int i = 1024, *p = &i, &r = i;
// int初始化    int类型p指针    int型r引用
// 也可以写作下面格式
int i = 1024;
int* p =& i;        // 正确，只是容易误导
int&r = i;            // 正确，只是容易被误导
```

#### 指向指针的指针

一般声明符中修饰符的个数没有限制。

以指针为例，指针是内存中的对象，像其他对象一样也有自己的地址，因此允许把指针的地址再存放到另一个指针当中。

通过`*`的个数可以区分指针的级别。如`***`表示指向(指针的指针)的指针，而`**`表示指向(指针)的指针。使用了几个`*`，对应也要使用几个解引用符`*`。

```cpp
#include <iostream>
 
int main()
{
    int ival = 1024;
    int *pi = &ival;
    int **ppi = &pi;
    std::cout << **ppi << std::endl;
    return 0;
}
 
```

#### 指向指针的引用

指针本身是对象，所以可以被指向，但是引用本身不是对象，就不能被指向。

因此引用其实也可以指向指针

```cpp
#include <iostream>
 
int main()
{
    int i = 42;
    int *p;         // int型指针p
    int *(&r) = p;  // int型i引用p指针,就是把指针对象p的地址给了引用r，所以r也可以看做是指针p的别名
 
    r = &i;         // r引用了p指针，所以也就是p指向i的地址
    *r = 0;         // 解引用r的地址将其设置为0，也就是p指向的值赋值0
    std::cout << *p << std::endl;
    return 0;
}
 
```

如果要理解`r`到底是什么，可以将代码从右往左看，看左边最接近`r`的是引用符`&`，所以`r`是个引用

也可以配合下面的代码加以理解

```cpp
#include <iostream>
 
int main()
{
    int i = 42;
    int *p = &i;    // int型指针p指向i
    int &r = *p;    // r获取解引用p的内容，也就是42
 
    std::cout << r << std::endl;
    return 0;
}
 
```

## const限定符

使用变量的好处是如果缓冲区大小不再合适的收我们可以轻易修改。

但有时我们也想我们的某些东西不能被修改

```cpp
const int 变量 = 值;            // 该变量不可修改
```

`const`必须被初始化值。

#### 默认状态下，const对象仅在文件内有效

解决办法，对于`const`变量不管是声明还是定义都添加`extern`关键字，这样只需定义一次就行了。

```c++
// 创建文件.cpp写入
extern const int bufSize = 512;
 
// 创建文件.h写入以下内容,表示指出bufSize并不是本文件所独有的,它的定义会在别的地方再次出现.
extern const int bufSize;
```

### const的引用

**对常量的引用**(reference to const)

```c++
const int ci = 1024;
const int &r1 = ci;
r1 = 42;		// 错误，常量引用不可修改
int &r2 = ci;	// 错误，非常量引用不可引用常量
```

#### 初始化和对const的引用

前面提过引用的类型必须与引用的对象的类型相同，但是有两个例外

1. 初始化常量引用时允许用任意表达式作为初始值，只要这个表达式的结果能转换成引用的类型就行。

   - ```c++
     int i = 42;
     const int &r1 = i;
     const int &r2 = r1 * 2;		// 只要r1与2的积结果可以转换成引用的类型(int)就行
     
     double dval = 3.14;
     const int &ri = dval;		
     // 事实上会把double类型的dval先转换成const int temp再给&ri，也就是ri = 3
     ```

   - 而在`double dval`到`const int &ri`之间执行的那个`const int temp = dval`中的`temp`称为**临时量**(temporary)对象。

   - 临时量是当编译器需要一个空间来暂时存放表达式的求值结果时临时创建的一个未命名的对象。

   - 也就是说其实`ri`绑定的是临时量`temp`而不是`dval`

   - C++把这种绑到临时量的行为归为非法行为。

2. 还没提

#### 对const的引用可能引起一个并非const的对象

常量引用只对可参与的操作做出了限制，对于引用的对象本身是不是一个常量没有限制。

也就是说我们使用常量引用时，不能通过常量引用去修改引用的对象，但是对象本身如果不是常量，那么对象本身修改也就不关常量引用什么事。

### 指针和const

**指向常量的指针**(pointer to const)不能用于改变其所指对象的值。要想存放常量对象的地址，只能使用指向常量的指针

```c++
const double pi = 3.14;
double* ptr = &pi;			// 指针ptr指向常量pi
const double *cptr = &pi;	// 常量双精度指针cptr指向pi
*cptr = 42;					// 修改常量指针的对象值，错误
```

之前提过指针的类型必须与所指对象的类型一致，但是有两个例外

1. 允许让一个指向常量的指针指向一个不是常量的对象

   - ```c++
     // 接上
     double dval = 3.14;
     cptr = &dval;		//正确，但是不能通过cptr修改dval的值
     ```

2. 没提

指向常量的指针也没规定所指对象必须是一个常量

#### const指针

 **常量指针**(const pointer)必须初始化，且初始化完成，它的值(在指针中的那个地址)就不能改了。

```c++
int errNumb = 0;
int *const curErr = &errNumb;		// curErr 将一直指向errNumb，不能指其他的对象
const double pi = 3.14159;
const double *const pip = &pi;		// pip 是一个指向常量对象的常量指针
```

把*放在const前用以说明指针是一个常量，有种说明改变的不是指针本身的值而是指向的那个值的意思。

离`curErr`(左边)最近的是`const`，说明它`curErr`首先是个常量对象，然后`*`说明`curErr`是个常量指针。

`pip`由此也能推断出是一个常量指针，所指对象是个双精度浮点型常量。

在上实例中虽然`curErr`是个常量指针，但是所指对象`errNumb`不是常量，所以可以通过`errNumb`的值来修改常量指针`curErr`的值。

但是`pip`就不能修改，且因为它所指的也是个常量，所以`pip`和`pi`的值都是固定不能改变的。

```c++
*pip = 2.72;		// 错误，指向常量的常量指针，不能修改值
if(*curErr){
	errorHandler();	// 不知道是啥
	*curErr = 0;	// 正确，只是修改curErr常量指针所指对象的值而非修改指针所指对象
}
```

### 示例题

```c++
// 一
int i = -1, &r = 0;					// &r错误，引用不可直接使用字面值常量初始化
int* const p2 = &i2;				// &i2错误，此时i2还没被初始化
const int i = -1, &r = 1;			// 正确，&r是常量引用，可以直接使用字面值常量初始化
const int *const p3 = &i2;			// 错误，i2还没被初始化
const int *pi = &i2;				// 错误，i2还没被初始化
const int &const r2;				// 错误，常量指针必须初始化
const int i2 = i, &r = i;			// 若i是个数,那么正确。如果没有i，就错误

// 二
int i, *const cp;					// 不合法，常量指针没有初始化
int *p1, *const p2;					// 不合法，常量指针没有初始化，且指针p1没有初始化也是个危险的玩意
const int ic, &r = ic;				// 不合法，常量ic没有初始化
const int *const p3;				// 不合法，指向常量的常量指针p3没有初始化
const int *p;						// 合法，p不是常量指针而是指向常量的指针

// 假设上述二的内容全部合法，分析下面是否正确
i = ic;								// 正确，常数ic赋给i
p1 = p3;							// 正确，指向常量的常量指针p3的地址赋给指针p1
p1 = &ic;							// 错误，p1不是指向常量的指针，因此不能指常量
p3 = &ic;							// 正确，指向常量的常量指向p3指向常量ic
p2 = p1;							// p2是常量指针，p1是指针，如果是赋值就错误，如果初始化就正确
ic = *p3;							// ic是常量，*p3是指向常量的常量指针p3解引用后的值，如果是赋值就错误，初始化就正确
```

### 顶层const

**顶层const**(top-level const)表示指针本身是个常量

**底层const**(low-level const)表示指针所指对象是个常量

```cpp
int i = 0;
int *const p1 = &i;			// p1是顶层const
const int ci = 42;			// ci是个顶层const，
const int *p2 = &ci;		// p2是个底层const，可以改p2的值
const int *const p3 = p2;	// *const的const是顶层const，const int的const是底层const
const int &r = ci;			// &r是底层const
```

举例，假如世界上有一个拇指姑娘和一个巨人，然后还有很多的鞋子

- 巨人的脚很大，只能穿巨人自己的鞋子(指针所指的对象)，那么就可以理解巨人的脚(指针)是个顶层const
- 拇指姑娘的脚很小，谁的鞋子她都能穿，拇指姑娘的脚就是底层const

执行对象的拷贝操作时候，拷入和拷出的对象必须具有相同的底层const资格。

一般而言，不是常量的也能转成常量，但常量就不能转成不是常量(如变量、指针、引用)的了。

```c++
// 接上述示例
i = ci;				// 正确 i = 42
p2 = p3;			// 正确 底层const顶层constp3的地址赋给底层constp2

int *p = p3;		// 错误，p3常量指针包含底层const含义，p指针没有
p2 = p3;			// 正确，p2和p3都有底层const含义
p2 = &i;			// 正确，&i可以被转成常量
int &r = ci;		// 错误，普通的int引用不能绑定到int常量上面
const int &r2 = i;	// 正确，变量i可以转成常量i
```

**可以记成，变量不能绑定到常量上面，但是常量可以绑定变量，因为常量绑定变量时候，会先把变量的值转成常量。**

#### 示例题

```cpp
const int v2 = 0;								// 此时v2是顶层 v2=0不可修改
int v1 = v2;									// 此时v1是顶层 v1=0不可修改
int *p1 = &v1, &r1 = v1;						// 此时p1是底层 r1是顶层也是底层 p1 = 0  r1 = 0
const int *p2 = &v2, *const p3 = &i, &r2 = v2;	// 此时p2是底层 p3是顶层也是底层 r2即是顶层也是底层 p2 = 0 p3 = 0
												// 注意阅读顺序，部分带&的表示引用，引用本身不可修改所以引用本身就是顶层
```

### constexpr和变量表达式

**常量表达式**(const expression)是指==值不会改变==并且在==编译过程==就可以得到计算结果的表达式。

字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式。

一个对象或者表达式是不是表达式需要根据它的数据类型和初始值决定

```c++
// 例
const int max_files = 20;			// max_files是常量表达式
const int limit = max_files + 1;	// 已知max_files是常量表达式，所以max_files+1后的limit也是常量表达式
int staff_size = 27;				// staff_size是个变量，未来可能变成其他东西，所以staff_size不是常量表达式
const int sz = get_size();			// 不知道get_size()函数返回的值是否固定，所以sz并不是常量表达式
```

#### constexpr常量

在复杂的系统里很难分辨一个初始值到底是不是常量表达式。

C++11新增允许将变量声明为constexpr类型以方便由编译器来验证变量的值到底是不是一个常量表达式。声明constexpr的变量一定是个常量，而且必须用常量表达式初始化：

```cpp
constexpr int mf = 20;				// 20是常量表达式
constexpr int limit = mf + 1;		// mf+1是常量表达式
constexpr int sz = size();			// 只有size是一个constexpr函数时候才是一条正确的声明语句
```

不能使用普通函数作为constexpr变量的初始值

> 一般而言，如果我们认定变量是一个常量表达式，那就把它声明称constexpr类型。

#### 字面值类型

常量表达式的值需要在编译时候就计算出来，所以对声明constexpr时用到的类型必须要有限制。因为这些类型一般比较简单，值也显而易见、容易获得，就称它们为**字面值类型**(literal type)。

在此之前的所有数据类型中，算术类型、引用和指针都属于字面值类型。其它如`Sales_item`、`iostream`、`string`就不属于字面值类型，也就不能被定义成`constexpr`。

虽然指针和引用都能定义成`constexpr`，但它们的初始值受到严格限制。一个`constexpr`指针的初始值必须是`nullptr`或者是`0`，或者是存储在某个固定地址中的对象。

后面会提到函数体里定义的变量的地址不是固定的，所以`constexpr`不能指向函数体里定义的变量。但是在所有函数体外面定义的对象它们的地址固定不变，就能用来初始化`constexpr`指针。且后面也会提到允许函数定义一类有效范围超出函数本身的变量，这类变量跟定义在所有函数体外的变量一样也有固定地址。so，`constexpr`引用能绑定到这样的变量上，`constexpr`指针也能指向这样的变量。

#### 指针和constexpr

必须知道，在`constexpr`声明中如果定义了一个指针，限定符`constexpr`只对指针有用，跟指针所指的对象没有关系

```c++
const int *p = nullptr;			// p是一个指向整型常量的指针，p是指向常量的指针，底层const
constexpr int *q = nullptr;		// q是一个指向整数的常量指针，q是常量指针       顶层const

constexpr int *np = nullptr;	// 顶层const
int j = 0;						// 在函数体里就是，普通变量
constexpr int i = 42;			// i的类型现在是整型常量了，前提是j和i都定义在所有函数体外
constexpr const int *p = &i;	// p是指向常量的常量指针，指向整型常量i
constexpr int *p1 = &j;			// 常量指针p1指向常量整数j

```

## 处理类型

随着程序越来越复杂，程序用到的类型也越来越复杂，有时会难拼写，有时会记错。

### 类型别名

**类型别名**(type alias)。使用类型别名可以让复杂的类型名字给我们更方便的使用。

有两种方法可以定义类型别名

1. ```c++
   typedef double wages;		// wages是double的同义词
   typedef wages base, *p;		// base是double的同义词，p是double*的同义词
   // double* (p)
   ```

```
   
2. ```c++
   using SI = Sales_item		// 给Sales_item定义同义词SI
```

   C++11新增的**别名声明**(alias declaration)，用于定义类型的别名

这种用关键字using作为别名声明的开始，其后紧跟别名和等号，其作用是把等号左侧的名字规定成等号右侧类型的别名。

#### 指针、常量和类型别名

```cpp
typedef char *pstring;
const pstring cstr = 0;			// cstr是指向char的常量指针
const pstring *ps;				// ps是一个指针，它的对象是指向char的常量指针
```

`const`是对给定类型的修饰。`pstring`实际上指向`char`的指针，因此，`const pstring`就是指向`char`的常量指针。

```c++
const char* cstr = nullptr;		// 这是错误的
```

### auto类型说明符

C++11新增

使用**auto**类型说明符可以让编译器替我们去分析表达式所属的类型。

使用auto声明的一条语句中只能有一个数据类型

```c++
auto item = val1 + val2;		// 由val1和val2相加的结果可以推断出item的类型
								// item初始化为val1+val2的结果

auto i = 0, *p = &i;			// 正确
auto sz = 0, pi = 3.14;			// 错误，一个int一个double类型不一样
```

#### 复合类型、常量和auto

编译器判断的auto类型有时候回合初始值的类型并不完全一样，编译器会适当地改变结果类型使其更加符合初始化规则。

```c++
int i = 0, &r = i;
auto a = r;				// a = 0
```

auto通常会忽略掉顶层const，但底层const会被保留

```c++
const int ci = i, &cr = ci;		// 顶层const ci值为0，顶层const引用cr = ci = 0
auto b = ci;	// b是一个整数0
auto c = cr;	// c = 0，cr是顶层const，所以c是整数
auto d = &i;	// d是一个整型指针(整数的地址就是指向整数的指针)
auto e = &ci;	// e是一个指向整数常量的指针(对常量对象取地址是一种底层const)

const auto f = ci;	// 明确指出f必然是个顶层const，ci的推演类型是int，f是const int

auto &g = ci;	// g是一个整型常量引用，绑定到ci
auto &h = 42;	// 错误，不能给不是常量的引用绑定字面值
const auto &j = 42;	// 正确，可以给常量引用绑定字面值
```

设置一个类型为auto的引用时，初始值的顶层常量属性仍然保留。和往常一样，如果我们给初始值绑定一个引用，那么此时的常量就不是顶层常量了。

```c++
auto k = ci, &l = i;		// k是整数，l是整型引用
auto &m = ci, *p = &ci;		// m是对整型常量的引用，p是指向整型常量的指针
auto &n = i, *p2 = &ci;		// 错误，i的类型是int，而&ci的类型是const int
```

#### 例题

```c++
#include <iostream>

int main(){
    const int i = 42;
    auto j = i;const auto &k = i;auto *p = &i;
    const auto j2 = i, &k2 = i;
    return 0;
}

/*
测试方式：查看每个标识符是否可以再被赋值
j是int
&k是const int
p是const int
j2和&k2都是const int
*/
```

### decltype类型指示符

C++11引入第二种类型说明符**decltype**

可以返回操作数的数据类型

```c++
decltype(f()) sum = x;		// sum的类型就是函数f的返回类型
```

编译器并不实际调用f函数，而是使用当调用f时返回值类型作为sum的类型。decltype使用的表达式如果是个变量，就返回该变量的类型，包括顶层const和引用在内。

```c++
const int ci = 0, &cj = ci;
decltype(ci) x = 0;				// x的类型是const int&，常量引用x = 0，引用不引用也都没区别了
decltype(cj) y = x;				// y的类型是const int&，y绑定到变量x
decltype(cj) z;					// 错误，z是一个引用，必须初始化
```

#### decltype和引用

```c++
int i = 42, *p = &i, &r = i;
decltype(r+0) b;		// int 42 + 0 = int
decltype(*p) c;			// int& c，错误，引用必须初始化，如果要使用引用的类型可以像上面一样+0
```

如果在给decltype传参数时候传递变量并加括号，那么编译器会把它当成表达式。变量是种可以作为赋值语句左值的特殊表达式，所以decltype就会得到引用类型

```c++
decltype((i)) d;		// 错误：d是int&，必须初始化
decltype(i) e;			// 正确
```

**decltype((variable))的结果永远是引用，而decltype(variable)的结果只有variable是引用才是引用**

若是赋值表达式，那么就会取左值的类型且变成引用，但是左值本身的值并不会变动

```c++
int a = 3, b = 4;
decltype(a) c = a;
decltype(a = b) d = a;
// a = 3, b = 4, c = 3, &d = a
```

## 自定义数据结构

### 自定义Sales_data类型

```c++
struct 类名{
类体
};
```

```c++
struct Sales_data{
    std::string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
};

struct Sales_data{
    ...
} accum, trans, *salesptr;		// Sales_data类对象accum，trans，*salesptr

struct Sales_data{
    ...
};
Sales_data accum, trans, *salesptr;
```

类体定义类的**成员**，我们的类只有**数据成员**(data member)。类的数据成员定义了类的对象的具体内容，每个对象有自己的一份数据成员拷贝。修改一个对象的数据成员，不会影响其他Sales_data的对象。

C++11新增，可以为数据成员提供一个**类内初始值**(in-class initializer)。创建对象时，类内初始值将用于初始化数据成员。没有初始值的成员将被默认初始化。因此当定义Sales_data对象时候，`units_sold`和`revenue`都将被初始化为0，bookNo将初始化为空字符串。

### 使用Sales_data类计算两本书的和

```c++
#include <iostream>
#include <string>
int main(){
    int ret = 0;
    struct Sales_data{
        std::string bookNo;
        unsigned units_sold = 0;
        double revenue = 0.0;
    };

    Sales_data data1, data2;
    double price = 0;
    std::cin >> data1.bookNo >> data1.units_sold >> price;
    data1.revenue = data1.units_sold * price;
    std::cin >> data2.bookNo >> data2.units_sold >> price;
    data2.revenue = data2.units_sold * price;
    if (data1.bookNo == data2.bookNo){
        unsigned totalCnt = data1.units_sold + data2.units_sold;
        double totalRevenue = data1.revenue + data2.revenue;
        // 输出ISBN、总销售量、总销售额
        std::cout << data1.bookNo << " " << totalCnt << " " << totalRevenue << " ";
        // 输出平均价格
        if (totalCnt != 0) std::cout << totalRevenue/totalCnt << std::endl;
        else std::cout << "无交易" << std::endl;
    }else{          // 两笔交易的ISBN不一致
        std::cerr << "Data must refer to the same ISBN" << std::endl;
        ret = -1;
    }
    std::cin >> ret;
    return ret;
}

/* 输入
0-201-78345-a 2 21.00
0-201-78345-a 2 22.00
*/
```

### 编写自己的头文件

类的头文件应该跟类的名字一样。头文件通常包含那些只能被定义一次的实体，如类、const和constexpr变量等。头文件也经常用到其他头文件的功能。

**头文件如果改变了，那么相关的头文件都必须重新编译来获得更新过的声明。**

#### 预处理器概述

确保头文件多次包含仍能安全工作的常用技术是**预处理器**(preprocessor)，从C语言中继承而来。

预处理器是在编译之前执行的一段程序，可以部分地改变我们所写的程序。例如`#include`就是预处理的一项功能，当预处理器看到`#include`标记时就会用指定的头文件的内容代替`#include`。

C++程序还会用到的一项预处理功能是**头文件保护符**(header guard)，头文件保护符依赖于预处理变量。

预处理变量有两种状态：

1. 已定义
2. 未定义

`#define`指令把一个名字设定为预处理变量，另外两个指令则分别检查某个指定的预处理变量是否已经定义：`ifdef`当变量已定义时为真，`#ifndef`当变量未定义时为真。一旦检查结果为真，则执行后续操作直至遇到`#endif`指令为止。使用这些功能就能有效地防止重复包含地发生：

```c++
#ifndef SALES_DATA_H		// 当预处理变量SALES_DATA_H没有定义时，就执行下面内容直到#endif
#define SALES_DATA_H		// 把SALES_DATA_H定义为预处理变量
#include <string>			// 告诉预处理器我们要使用string库
struct Sales_data{			// 定义Sales_data类
    std::string bookNo;		// 生成数据成员bookNo string对象bookNo
    unsigned units_sold = 0;// 生成数据成员units_sold 初始化无符号int类型units_sold变量为0
    double revenue = 0.0;	// 生成数据成员revenue 初始化双精度浮点型变量revenue变量为0.0
};
#endif
```

第一次包含`Sales_data.h`时候，`#ifndef`的检查结果为真，预处理器将顺序执行后面的操作直到遇到`#endif`为止。此时，预处理变量`SALES_DATA_H`的值将变成已定义，而且`Sales_data.h`也会被拷贝到我们的程序中来。后面如果再一次包含`Sales_data.h`，则`#ifndef`的检查结果为假，编译器将忽略`#ifndef`到`#endif`之间的部分。

**预处理变量无视C++语言中关于作用域的规则。**

整个程序中的预处理变量包括头文件保护符必须唯一，通常的做法是基于头文件中类的名字来构建保护符的名字，以确保其唯一性。为了避免与程序中的其他实体发生名字冲突，一般把预处理变量的名字全部大写。

> 头文件即使(目前)没有被包含在任何其他头文件中，也应该设置保护符。头文件保护符很简单，程序员只要习惯性地加上就可以了，没必要太在乎你的程序到底需不需要。
