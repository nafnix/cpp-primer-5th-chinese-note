# 模板与泛型编程

## 定义模板

如果给每种类型都定义完全一样的函数体，是非常烦琐且容易出错的。

### 函数模板

定义一个通用的**函数模板**(function template)，模板定义以关键字`template`开始，后跟**模板参数列表**(template parameter list)，这是一个逗号分隔的**模板参数**(template parameter)的列表，不能是空。

```cpp
template <typename T> int compare(const T &v1, const T &v2){
    if (v1 < v2) return -1;
    if (v2 < v1) return 1;
    return 0;
}
```

当使用模板时，隐式或显式地指定**模板实参**(template argument)，将其绑定到模板实参上。

编译器用推断出的模板实参来为我们**实例化**(instantiate)一个特定版本的函数。

编译器实例化一个模板的时候，它使用实际的模板实参代替对应地模板参数来创建出模板地一个新实例。

这些编译器生成的版本通常被称为模板的**实例**(instantiation)。

上例`compare`函数有个模板**类型参数**(type parameter)。可以把类型参数看作类型说明符。类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或者类型转换：

```cpp
// 正确
template <typename T> T foo(T* p)		// T是类型参数
{
    T tmp = *p;			// tmp的类型将是指针p指向的类型
    // ...snap install spotify
    return tmp;
}
```

每个类型参数前都必须要加`class`或者`typename`。

`typename`是在模板已经广泛使用后才引入C++的，而有些人更习惯用`class`。

还可以在模板里定义**非类型参数**(nonetype parameter)。一个非类型参数表示一个值而非类型。

当模板被实例化时，非类型参数被一个用户提供的或编译器推断出的值所代替。这些值必须是常量表达式。

```cpp
template<unsigned N, unsigned M> int compare(const char (&p1)[N], const char(&p2)[M]){
    return strcmp(p1, p2);
}

compare("hi", "hello");
```

编译器实例化版本：

```cpp
// 编译器用字面常量的大小来代替N和M 从而实例化模板
int compare(const char (&p1)[3], const char (&p2)[6])
```

函数模板可以声明成`inline`或`constexpr`的。它们都放在模板参数列表后，返回类型前：

```cpp
// 正确
template <typename T> inline T min(const T&, const T&);
// 错误
inline template <typename T> T min(const T&, const T&);
```

通过将函数参数设为`const`引用，保证了函数可以用于不能拷贝的类型。

`compare`函数说明编写泛型代码的两个重要原则：

1. 模板中的函数参数是`const`的引用：保证函数可以用于不能拷贝的类型；也能使得处理大对象时速度更快
2. 函数体中的条件判断只用`<`比较：降低了`compare`函数对于要处理的类型的要求

如果真的关心类型和可移植性，可能要用`less`：

```cpp
template <typename T> int compare(const T &val1, const T &val2)
{
    if (less<T>()(val1, val2)) return -1;
    if (less<T>()(val2, val1)) return 1;
    return 0;
}
```

原始版本的问题是如果比较指针，可能出现未定义的结果。

其实`less<T>`的默认实现也是用的`<`。

模板程序应该尽量减少对于实参类型的依赖。

#### 模板编译

编译器遇到模板定义不会生成代码。只有实例化出模板后才会生成代码。这影响我们如何组织代码以及错误何时被检测到。

通常会把类定义和函数声明放在头文件里，而普通函数和类的成员函数定义在源文件里。

但是为了生成模板的实例化版本，编译器要了解函数模板或类模板成员函数的定义。所以模板的头文件通常既有声明又有定义。

函数模板和类模板成员函数定义通常放在头文件里。

#### 关键概念：模板和头文件

模板包含两种名字：

1. 不依赖模板参数的名字
2. 以来模板参数的名字

使用模板时，不依赖模板参数的名字必须可见，且模板被实例化时，模板定义包括类模板的成员的定义必须可见，由模板提供者保证。

用来实例化模板的所有函数、类型以及与类型关联的运算符的声明都必须可见，由模板用户保证。

模板设计者应该提供一个头文件，包含模板定义以及在类模板或成员定义中用到的所有名字的声明。

模板的用户必须包含模板的头文件，以及用来实例化模板的任何类型的头文件。

#### 大多数编译错误在实例化期间报告

编译器会在三个阶段报告错误：：

1. 编译模板本身。检查语法错误。
2. 编译遇到模板。检查实参数目或是参数类型是否匹配。对于类模板，编译器可以检查用户是否提供了正确数目的模板实参。
3. 模板实例化时，发现与类型相同的错误。依赖于编译器如果管理实例化，这类错误可能在链接时才报告。

编写模板时，代码不应该针对某种特定类型，但是通常会对所用的类型做些假设。比如假定类型已经有了`<`。

保证传递给模板的实参支持模板所要求的操作，以及这些操作在模板中能够正确工作，是调用者的责任。

### 类模板

**类模板**(class template)用于生成类的蓝图。

编译器不能为类模板推断模板参数类型。为了用类模板，必须在模板名后的尖括号提供额外信息——用于替换模板参数的模板实参列表。

#### 定义类模板

```cpp
#include <memory>
#include <initializer_list>
#include <vector>
#include <string>

template <typename T> class Blob {

public:
    typedef T value_type;
    typedef typename std::vector<T>::size_type size_type;

    // 构造函数
    Blob();
    Blob(std::initializer_list<T> il);

    // Blob的元素数目
    size_type size() const { return data->size(); }
    bool empty() const { return data->empty(); }

    // 添加或删除元素
    void push_back(const T &t) { data->push_back(t); }

    // 移动
    void push_back(T &&t) { data->push_back(std::move(t)); }

    // 弹出
    void pop_back();

    // 元素访问
    T& back();
    T& operator[](size_type i);

private:
    std::shared_ptr<std::vector<T>> data;

    // 若data[i]无效 则抛出msg
    void check(size_type i, const std::string &msg) const;
};
```

有个名为`T`的模板类型参数，用来表示`Blob`保存的元素类型。

#### 实例化类模板

使用类模板时提供额外信息，这些额外是**显式模板实参**(explicit template argument)列表，它们被绑定到模板参数。

编译器用这些模板实参来实例化出特定的类。

```cpp
Blob<int> ia;			// 显式模板实参 <int>
```

编译器实例化出与下面代码等价的类：

```cpp
template <> class Blob<int> {
    typedef typename std::vector<int>::size_type size_type;
    Blob();
    Blob(std::initializer_list<int> il);
    // ...
    int& operator[](size_type i);
private:
    std::shared_ptr<std::vector<int>> data;
    void check(size_type i, const std::string &msg) const;
};
```

每个类模板的每个实例都是一个独立的类。类型`Blob<string>`与任何其他`Blob`类型都没有关联，也不会对其他`Blob`类型的成员有特殊访问权限。

#### 模板作用域里引用模板类型

类模板用来实例化类型，而一个实例化的类型总是包含模板参数。

如果一个类模板里用了另一个模板，一般都是用模板自己的参数当作被用模板的实参：

```cpp
std::shared_ptr<std::vector<T>> data;		// 创建vector时用了T
```

#### 类模板的成员函数

类模板的每个实例都有自己版本，所以类模板的成员函数具有和模板相同的模板参数。所以定义在类模板类外的成员函数要以`template`开头，后接类模板参数列表。

格式：

```cpp
template <typename T> 
return-type Blob<T>::member-name(parm-list)
```

#### check和元素访问成员

```cpp
// 定义check 用于检查给定索引
template <typename T>
void Blob<T>::check(size_type i, const std::string &msg) const
{
    if (i >= data->size())
        throw std::out_of_range(msg);
}

// 定义back 用于检查是否为空
template <typename T>
T& Blob<T>::back()
{
    check(0, "back on empty Blob");
    return data->back();
}

// 定义下标运算符
template <typename T>
T& Blob<T>::operator[](size_type i)
{
    // 若i太大 则check抛出 阻止访问一个不存在的元素
    check(i, "subscript out of range");
    return (*data)[i];
}
```

#### Blob构造函数

```cpp
template <typename T>
Blob<T>::Blob(): data(std::make_shared<std::vector<T>>()) { }
```

这段代码在作用域`Blob<T>`里定义了名为`Blob`的成员函数。该构造函数分配一个空`vector`，并将指向`vector`的指针保存在`data`里。

类似，接受一个`initializer_list`参数的构造函数将其类型参数`T`作为`initializer_list`参数的元素类型：

```cpp
template <typename T>
Blob<T>::Blob(std::initializer_list<T> il):
    data(std::make_shared<std::vector<T>>(il)) { }
```

类似默认构造函数，该构造函数分配一个`initializer_list`，其中的元素必须与`Blob`的元素类兼容：

```cpp
Blob<string> articles = {"a"};		// 构造函数的参数类型时initializer_list<string> 列表中的每个字符串字面常量隐式转换成string
```

#### 类模板成员函数的实例化

默认一个类模板的成员函数只有在程序用到它的时候才会实例化。这个特性使得即使某种类型不能完全符合模板操作的要求，还是能用这个类型实例化类。

比如马(类模板)和驴(类型)能生出骡(实例化类)，但是螺子能不能用来做事只有让它做事的时候才能知道。

#### 在类代码里简化模板类名的使用

使用类模板类型时候必须提供模板实参，但有个例外。如果在类模板自己的作用域内，可以直接用模板名而不提供类模板类型实参：

```cpp
template <typename T> class BlobPtr{
public:
    BlobPtr(): curr(0) { }
    BlobPtr(Blob<T> &a, size_t sz = 0): wptr(a.data), curr(sz) { }

    T& operator*() const{
        auto p = check(curr, "dereference past end");
        return (*p)[curr];      // (*p)为本对象指向的vector
    }

    BlobPtr& operator++();      // 前置递增运算符
    BlobPtr& operator--();      // 前置递减运算符
private:
    // 如果检查成功 check返回一个指向vector的shared_ptr
    std::shared_ptr<std::vector<T>> check(std::size_t, const std::string&) const;

    // 保存一个weak_ptr 表示底层vector可能被销毁
    std::weak_ptr<std::vector<T>> wptr;
    std::size_t curr;           // 数组中的当前位置
};
```

如上代码所示：

```cpp
BlobPtr& operator++();      // 前置递增运算符
BlobPtr& operator--();      // 前置递减运算符
```
没有指定模板类型。

#### 类模板外使用类模板名

类模板外定义成员时，就要指出类模板类型了：

```cpp
template <typename T>
BlobPtr<T> BlobPtr<T>::operator++(int)
{
    // 无须检查 调用前置递增会进行检查
    BlobPtr ret = *this;    // 保存当前值
    ++*this;                // 推进 前置递增会自己检查是否合法
    return ret;             // 返回保存的状态
}
```

因为返回类型在类模板作用域外，所以需要指出返回类型，而`BlobPtr ret = *this;`处在作用域内就不需要。

#### 类模板和友元

- 非模板友元：则友元被授权可以访问所有类模板实例。
- 模板友元：
  - 类模板可以授权给所有友元模板实例
  - 类模板可以只授权给特定实例

#### 一对一友好关系

