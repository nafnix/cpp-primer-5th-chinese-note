# 模板与泛型编程

## 定义模板

如果给每种类型都定义完全一样的函数体，是非常烦琐且容易出错的。

### 函数模板

定义一个通用的**函数模板**(function template)，模板定义以关键字`template`开始，后跟**模板参数列表**(template parameter list)，这是一个逗号分隔的**模板参数**(template parameter)的列表，不能是空。

```cpp
template <typename T> int compare(const T &v1, const T &v2){
    if (v1 < v2) return -1;
    if (v2 < v1) return 1;
    return 0;
}
```

当使用模板时，隐式或显式地指定**模板实参**(template argument)，将其绑定到模板实参上。

编译器用推断出的模板实参来为我们**实例化**(instantiate)一个特定版本的函数。

编译器实例化一个模板的时候，它使用实际的模板实参代替对应地模板参数来创建出模板地一个新实例。

这些编译器生成的版本通常被称为模板的**实例**(instantiation)。

上例`compare`函数有个模板**类型参数**(type parameter)。可以把类型参数看作类型说明符。类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或者类型转换：

```cpp
// 正确
template <typename T> T foo(T* p)		// T是类型参数
{
    T tmp = *p;			// tmp的类型将是指针p指向的类型
    // ...snap install spotify
    return tmp;
}
```

每个类型参数前都必须要加`class`或者`typename`。

`typename`是在模板已经广泛使用后才引入C++的，而有些人更习惯用`class`。

还可以在模板里定义**非类型参数**(nonetype parameter)。一个非类型参数表示一个值而非类型。

当模板被实例化时，非类型参数被一个用户提供的或编译器推断出的值所代替。这些值必须是常量表达式。

```cpp
template<unsigned N, unsigned M> int compare(const char (&p1)[N], const char(&p2)[M]){
    return strcmp(p1, p2);
}

compare("hi", "hello");
```

编译器实例化版本：

```cpp
// 编译器用字面常量的大小来代替N和M 从而实例化模板
int compare(const char (&p1)[3], const char (&p2)[6])
```

函数模板可以声明成`inline`或`constexpr`的。它们都放在模板参数列表后，返回类型前：

```cpp
// 正确
template <typename T> inline T min(const T&, const T&);
// 错误
inline template <typename T> T min(const T&, const T&);
```

通过将函数参数设为`const`引用，保证了函数可以用于不能拷贝的类型。

`compare`函数说明编写泛型代码的两个重要原则：

1. 模板中的函数参数是`const`的引用
2. 函数体中的条件判断只用`<`比较