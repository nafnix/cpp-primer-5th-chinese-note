# 模板与泛型编程

## 定义模板

如果给每种类型都定义完全一样的函数体，是非常烦琐且容易出错的。

### 函数模板

定义一个通用的**函数模板**(function template)，模板定义以关键字`template`开始，后跟**模板参数列表**(template parameter list)，这是一个逗号分隔的**模板参数**(template parameter)的列表，不能是空。

```cpp
template <typename T> int compare(const T &v1, const T &v2){
    if (v1 < v2) return -1;
    if (v2 < v1) return 1;
    return 0;
}
```

当使用模板时，隐式或显式地指定**模板实参**(template argument)，将其绑定到模板实参上。

编译器用推断出的模板实参来为我们**实例化**(instantiate)一个特定版本的函数。

编译器实例化一个模板的时候，它使用实际的模板实参代替对应地模板参数来创建出模板地一个新实例。

这些编译器生成的版本通常被称为模板的**实例**(instantiation)。

上例`compare`函数有个模板**类型参数**(type parameter)。可以把类型参数看作类型说明符。类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或者类型转换：

```cpp
// 正确
template <typename T> T foo(T* p)		// T是类型参数
{
    T tmp = *p;			// tmp的类型将是指针p指向的类型
    // ...snap install spotify
    return tmp;
}
```

每个类型参数前都必须要加`class`或者`typename`。

`typename`是在模板已经广泛使用后才引入C++的，而有些人更习惯用`class`。

还可以在模板里定义**非类型参数**(nonetype parameter)。一个非类型参数表示一个值而非类型。

当模板被实例化时，非类型参数被一个用户提供的或编译器推断出的值所代替。这些值必须是常量表达式。

```cpp
template<unsigned N, unsigned M> int compare(const char (&p1)[N], const char(&p2)[M]){
    return strcmp(p1, p2);
}

compare("hi", "hello");
```

编译器实例化版本：

```cpp
// 编译器用字面常量的大小来代替N和M 从而实例化模板
int compare(const char (&p1)[3], const char (&p2)[6])
```

函数模板可以声明成`inline`或`constexpr`的。它们都放在模板参数列表后，返回类型前：

```cpp
// 正确
template <typename T> inline T min(const T&, const T&);
// 错误
inline template <typename T> T min(const T&, const T&);
```

通过将函数参数设为`const`引用，保证了函数可以用于不能拷贝的类型。

`compare`函数说明编写泛型代码的两个重要原则：

1. 模板中的函数参数是`const`的引用：保证函数可以用于不能拷贝的类型；也能使得处理大对象时速度更快
2. 函数体中的条件判断只用`<`比较：降低了`compare`函数对于要处理的类型的要求

如果真的关心类型和可移植性，可能要用`less`：

```cpp
template <typename T> int compare(const T &val1, const T &val2)
{
    if (less<T>()(val1, val2)) return -1;
    if (less<T>()(val2, val1)) return 1;
    return 0;
}
```

原始版本的问题是如果比较指针，可能出现未定义的结果。

其实`less<T>`的默认实现也是用的`<`。

模板程序应该尽量减少对于实参类型的依赖。

#### 模板编译

编译器遇到模板定义不会生成代码。只有实例化出模板后才会生成代码。这影响我们如何组织代码以及错误何时被检测到。

通常会把类定义和函数声明放在头文件里，而普通函数和类的成员函数定义在源文件里。

但是为了生成模板的实例化版本，编译器要了解函数模板或类模板成员函数的定义。所以模板的头文件通常既有声明又有定义。

函数模板和类模板成员函数定义通常放在头文件里。

#### 关键概念：模板和头文件

模板包含两种名字：

1. 不依赖模板参数的名字
2. 以来模板参数的名字

使用模板时，不依赖模板参数的名字必须可见，且模板被实例化时，模板定义包括类模板的成员的定义必须可见，由模板提供者保证。

用来实例化模板的所有函数、类型以及与类型关联的运算符的声明都必须可见，由模板用户保证。

模板设计者应该提供一个头文件，包含模板定义以及在类模板或成员定义中用到的所有名字的声明。

模板的用户必须包含模板的头文件，以及用来实例化模板的任何类型的头文件。

#### 大多数编译错误在实例化期间报告

编译器会在三个阶段报告错误：：

1. 编译模板本身。检查语法错误。
2. 编译遇到模板。检查实参数目或是参数类型是否匹配。对于类模板，编译器可以检查用户是否提供了正确数目的模板实参。
3. 模板实例化时，发现与类型相同的错误。依赖于编译器如果管理实例化，这类错误可能在链接时才报告。

编写模板时，代码不应该针对某种特定类型，但是通常会对所用的类型做些假设。比如假定类型已经有了`<`。

保证传递给模板的实参支持模板所要求的操作，以及这些操作在模板中能够正确工作，是调用者的责任。

### 类模板

