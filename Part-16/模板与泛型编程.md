# 模板与泛型编程

## 定义模板

如果给每种类型都定义完全一样的函数体，是非常烦琐且容易出错的。

### 函数模板

定义一个通用的**函数模板**(function template)，模板定义以关键字`template`开始，后跟**模板参数列表**(template parameter list)，这是一个逗号分隔的**模板参数**(template parameter)的列表，不能是空。

```cpp
template <typename T> int compare(const T &v1, const T &v2){
    if (v1 < v2) return -1;
    if (v2 < v1) return 1;
    return 0;
}
```

当使用模板时，隐式或显式地指定**模板实参**(template argument)，将其绑定到模板实参上。

编译器用推断出的模板实参来为我们**实例化**(instantiate)一个特定版本的函数。

编译器实例化一个模板的时候，它使用实际的模板实参代替对应地模板参数来创建出模板地一个新实例。

这些编译器生成的版本通常被称为模板的**实例**(instantiation)。

上例`compare`函数有个模板**类型参数**(type parameter)。可以把类型参数看作类型说明符。类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或者类型转换：

```cpp
// 正确
template <typename T> T foo(T* p)		// T是类型参数
{
    T tmp = *p;			// tmp的类型将是指针p指向的类型
    // ...snap install spotify
    return tmp;
}
```

每个类型参数前都必须要加`class`或者`typename`。

`typename`是在模板已经广泛使用后才引入C++的，而有些人更习惯用`class`。

还可以在模板里定义**非类型参数**(nonetype parameter)。一个非类型参数表示一个值而非类型。

当模板被实例化时，非类型参数被一个用户提供的或编译器推断出的值所代替。这些值必须是常量表达式。

```cpp
template<unsigned N, unsigned M> int compare(const char (&p1)[N], const char(&p2)[M]){
    return strcmp(p1, p2);
}

compare("hi", "hello");
```

编译器实例化版本：

```cpp
// 编译器用字面常量的大小来代替N和M 从而实例化模板
int compare(const char (&p1)[3], const char (&p2)[6])
```

函数模板可以声明成`inline`或`constexpr`的。它们都放在模板参数列表后，返回类型前：

```cpp
// 正确
template <typename T> inline T min(const T&, const T&);
// 错误
inline template <typename T> T min(const T&, const T&);
```

通过将函数参数设为`const`引用，保证了函数可以用于不能拷贝的类型。

`compare`函数说明编写泛型代码的两个重要原则：

1. 模板中的函数参数是`const`的引用：保证函数可以用于不能拷贝的类型；也能使得处理大对象时速度更快
2. 函数体中的条件判断只用`<`比较：降低了`compare`函数对于要处理的类型的要求

如果真的关心类型和可移植性，可能要用`less`：

```cpp
template <typename T> int compare(const T &val1, const T &val2)
{
    if (less<T>()(val1, val2)) return -1;
    if (less<T>()(val2, val1)) return 1;
    return 0;
}
```

原始版本的问题是如果比较指针，可能出现未定义的结果。

其实`less<T>`的默认实现也是用的`<`。

模板程序应该尽量减少对于实参类型的依赖。

#### 模板编译

编译器遇到模板定义不会生成代码。只有实例化出模板后才会生成代码。这影响我们如何组织代码以及错误何时被检测到。

通常会把类定义和函数声明放在头文件里，而普通函数和类的成员函数定义在源文件里。

但是为了生成模板的实例化版本，编译器要了解函数模板或类模板成员函数的定义。所以模板的头文件通常既有声明又有定义。

函数模板和类模板成员函数定义通常放在头文件里。

#### 关键概念：模板和头文件

模板包含两种名字：

1. 不依赖模板参数的名字
2. 以来模板参数的名字

使用模板时，不依赖模板参数的名字必须可见，且模板被实例化时，模板定义包括类模板的成员的定义必须可见，由模板提供者保证。

用来实例化模板的所有函数、类型以及与类型关联的运算符的声明都必须可见，由模板用户保证。

模板设计者应该提供一个头文件，包含模板定义以及在类模板或成员定义中用到的所有名字的声明。

模板的用户必须包含模板的头文件，以及用来实例化模板的任何类型的头文件。

#### 大多数编译错误在实例化期间报告

编译器会在三个阶段报告错误：：

1. 编译模板本身。检查语法错误。
2. 编译遇到模板。检查实参数目或是参数类型是否匹配。对于类模板，编译器可以检查用户是否提供了正确数目的模板实参。
3. 模板实例化时，发现与类型相同的错误。依赖于编译器如果管理实例化，这类错误可能在链接时才报告。

编写模板时，代码不应该针对某种特定类型，但是通常会对所用的类型做些假设。比如假定类型已经有了`<`。

保证传递给模板的实参支持模板所要求的操作，以及这些操作在模板中能够正确工作，是调用者的责任。

### 类模板

**类模板**(class template)用于生成类的蓝图。

编译器不能为类模板推断模板参数类型。为了用类模板，必须在模板名后的尖括号提供额外信息——用于替换模板参数的模板实参列表。

#### 定义类模板

```cpp
#include <memory>
#include <initializer_list>
#include <vector>
#include <string>

template <typename T> class Blob {

public:
    typedef T value_type;
    typedef typename std::vector<T>::size_type size_type;

    // 构造函数
    Blob();
    Blob(std::initializer_list<T> il);

    // Blob的元素数目
    size_type size() const { return data->size(); }
    bool empty() const { return data->empty(); }

    // 添加或删除元素
    void push_back(const T &t) { data->push_back(t); }

    // 移动
    void push_back(T &&t) { data->push_back(std::move(t)); }

    // 弹出
    void pop_back();

    // 元素访问
    T& back();
    T& operator[](size_type i);

private:
    std::shared_ptr<std::vector<T>> data;

    // 若data[i]无效 则抛出msg
    void check(size_type i, const std::string &msg) const;
};
```

有个名为`T`的模板类型参数，用来表示`Blob`保存的元素类型。

#### 实例化类模板

使用类模板时提供额外信息，这些额外是**显式模板实参**(explicit template argument)列表，它们被绑定到模板参数。

编译器用这些模板实参来实例化出特定的类。

```cpp
Blob<int> ia;			// 显式模板实参 <int>
```

编译器实例化出与下面代码等价的类：

```cpp
template <> class Blob<int> {
    typedef typename std::vector<int>::size_type size_type;
    Blob();
    Blob(std::initializer_list<int> il);
    // ...
    int& operator[](size_type i);
private:
    std::shared_ptr<std::vector<int>> data;
    void check(size_type i, const std::string &msg) const;
};
```

每个类模板的每个实例都是一个独立的类。类型`Blob<string>`与任何其他`Blob`类型都没有关联，也不会对其他`Blob`类型的成员有特殊访问权限。

#### 模板作用域里引用模板类型

类模板用来实例化类型，而一个实例化的类型总是包含模板参数。

如果一个类模板里用了另一个模板，一般都是用模板自己的参数当作被用模板的实参：

```cpp
std::shared_ptr<std::vector<T>> data;		// 创建vector时用了T
```

#### 类模板的成员函数

类模板的每个实例都有自己版本，所以类模板的成员函数具有和模板相同的模板参数。所以定义在类模板类外的成员函数要以`template`开头，后接类模板参数列表。

格式：

```cpp
template <typename T> 
return-type Blob<T>::member-name(parm-list)
```

#### check和元素访问成员

```cpp
// 定义check 用于检查给定索引
template <typename T>
void Blob<T>::check(size_type i, const std::string &msg) const
{
    if (i >= data->size())
        throw std::out_of_range(msg);
}

// 定义back 用于检查是否为空
template <typename T>
T& Blob<T>::back()
{
    check(0, "back on empty Blob");
    return data->back();
}

// 定义下标运算符
template <typename T>
T& Blob<T>::operator[](size_type i)
{
    // 若i太大 则check抛出 阻止访问一个不存在的元素
    check(i, "subscript out of range");
    return (*data)[i];
}
```

#### Blob构造函数

```cpp
template <typename T>
Blob<T>::Blob(): data(std::make_shared<std::vector<T>>()) { }
```

这段代码在作用域`Blob<T>`里定义了名为`Blob`的成员函数。该构造函数分配一个空`vector`，并将指向`vector`的指针保存在`data`里。

类似，接受一个`initializer_list`参数的构造函数将其类型参数`T`作为`initializer_list`参数的元素类型：

```cpp
template <typename T>
Blob<T>::Blob(std::initializer_list<T> il):
    data(std::make_shared<std::vector<T>>(il)) { }
```

类似默认构造函数，该构造函数分配一个`initializer_list`，其中的元素必须与`Blob`的元素类兼容：

```cpp
Blob<string> articles = {"a"};		// 构造函数的参数类型时initializer_list<string> 列表中的每个字符串字面常量隐式转换成string
```

#### 类模板成员函数的实例化

默认一个类模板的成员函数只有在程序用到它的时候才会实例化。这个特性使得即使某种类型不能完全符合模板操作的要求，还是能用这个类型实例化类。

比如马(类模板)和驴(类型)能生出骡(实例化类)，但是螺子能不能用来做事只有让它做事的时候才能知道。

#### 在类代码里简化模板类名的使用

使用类模板类型时候必须提供模板实参，但有个例外。如果在类模板自己的作用域内，可以直接用模板名而不提供类模板类型实参：

```cpp
template <typename T> class BlobPtr{
public:
    BlobPtr(): curr(0) { }
    BlobPtr(Blob<T> &a, size_t sz = 0): wptr(a.data), curr(sz) { }

    T& operator*() const{
        auto p = check(curr, "dereference past end");
        return (*p)[curr];      // (*p)为本对象指向的vector
    }

    BlobPtr& operator++();      // 前置递增运算符
    BlobPtr& operator--();      // 前置递减运算符
private:
    // 如果检查成功 check返回一个指向vector的shared_ptr
    std::shared_ptr<std::vector<T>> check(std::size_t, const std::string&) const;

    // 保存一个weak_ptr 表示底层vector可能被销毁
    std::weak_ptr<std::vector<T>> wptr;
    std::size_t curr;           // 数组中的当前位置
};
```

如上代码所示：

```cpp
BlobPtr& operator++();      // 前置递增运算符
BlobPtr& operator--();      // 前置递减运算符
```
没有指定模板类型。

#### 类模板外使用类模板名

类模板外定义成员时，就要指出类模板类型了：

```cpp
template <typename T>
BlobPtr<T> &BlobPtr<T>::operator++()
{
    // 无须检查 调用前置递增会进行检查
    BlobPtr ret = *this;    // 保存当前值
    ++*this;                // 推进 前置递增会自己检查是否合法
    return ret;             // 返回保存的状态
}
```

因为返回类型在类模板作用域外，所以需要指出返回类型，而`BlobPtr ret = *this;`处在作用域内就不需要。

#### 类模板和友元

- 非模板友元：则友元被授权可以访问所有类模板实例。
- 模板友元：
  - 类模板可以授权给所有友元模板实例
  - 类模板可以只授权给特定实例

#### 一对一友好关系

类模板与另一个模板间友好关系的最常见形式是建立对应实例以及其友元间的友好关系。

例如将`BlobPtr`类和一个模板版本的`Blob`的相等运算符定义为友元。

为了引用模板的一个特定实例，需要先声明模板：

```cpp
template <typename> class BlobPtr;
template <typename> class Blob;
template <typename T> bool operator==(const Blob<T>&, const Blob<T>&);
```

然后定义友元：

```cpp
template <typename T> class Blob {
    // 每个Blob实例将访问权限授予用相同类型实例化的BlobPtr和相等运算符
    friend class BlobPtr<T>;
    friend bool operator==<T>
        (const Blob<T>, const Blob<T>);
// ...
};
```

友元的声明用`Blob`的模板形参作为它们自己的模板实参。所以友好关系被限定在用相同类型实例化的`Blob`与`Blobptr`相等运算符之间。

#### 通用和特定的模板友好关系

一个类也可以把另一个模板的每个实例都声明成自己的友元，或是限定特定的实例为友元：

```cpp
template <typename T> class Pal;

// 普通非模板类
class C
{
    friend class Pal<C>;        // 用类C实例化的Pal是C的友元
    // Pal2的所有实例都是C的友元 这种情况无须前置声明
    template <typename> friend class Pal;
};

// 模板类
template <typename T> class  C2
{
    // C2的每个实例都将相同实例化的Pal声明为友元
    friend class Pal<T>;                // Pal的模板声明必须在作用域里
    // Pal2的所有实例都是C2的每个实例的友元 不需要前置声明
    template <typename X> friend class Pal2;
    // Pal3是个非模板类 它是C2所有实例的友元
    friend class Pal3;                  // 不需要Pal3的前置声明
};
```

#### 令模板自己的类型参数成为友元

C++11后，可以把模板类型参数声明为友元：

```cpp
template <typename Type> class Bar
{
friend Type;        // 将访问权限授予用来实例化Bar的类型
};
```

#### 模板类型别名

可以定义一个`typefef`来引用一个实例化的类：

```cpp
typedef Blob<string> StrBlob;
```

但不能用一个`typefef`引用`Blob<T>`。但是C++11后允许我们为类模板定义一个类型别名：

```cpp
using namespace std;

template <typename T> using twin = pair<T, T>;	// 模板声明无法出现在块作用域里，所以要在主函数外定义

int main()
{
	twin<string> authors;			// authors是pair<string, string>
 
    twin<int> win_loss;				// win_loss是pair<int, int>
    
    system("pause");
    return 0;
}
```

也可以固定一个或者多个模板参数：

```cpp
template <typename T> using partNo = pair<T, int>;
	
	partNo<string> books;		// books是pair<string, int>
```

#### 类模板的static成员

```cpp
template <typename T> class Foo
{
public:
    static std::size_t count() { return ctr; }

private:
    static std::size_t ctr;
};
```

每个`Foo`的实例都有其自己的`static`成员实例。例如：

```cpp
// 实例化static成员Foo<string>::ctr和Foo<string>::count
Foo<string> fs;

// 下面的三个对象共享相同的Foo<int>::ctr和Foo<int>::count
Foo<int> f1, f2, f3;
```

模板类的每个`static`数据成员必须有且只有一个定义。但是类模板的每个实例都有一个独有的`static`对象。所以也把`static`成员定义为模板：

```cpp
template <typename T>
size_t Foo<T>::ctr = 0;
```

访问示例：

```cpp
Foo<int> f1;		// 实例化Foo<int>类和static数据成员ctr
auto ct = Foo<int>::count();		// 实例化Foo<int>::count
ct = f1.count();		// 使用Foo<int>::count
ct = Foo::count();		// 错误 不知道在用哪个版本的count
```

`static`成员也是只有在使用时才会实例化。

### 模板参数

模板参数的名字没什么内在含义。想叫啥都行。

#### 模板参数与作用域

模板参数的可用范围是声明之后到模板声明结束或定义结束之前。

模板参数会隐藏外层作用域中声明的相同名字。但是与其他上下文不同之处在于模板内不能重用模板参数名：

```cpp
typedef double A;
template <typename A, typename B> void f(A a, B b)
{
    A tmp = a;			// tmp的类型是A
    double B;			// 错误 重命名参数B
}
```

因为参数名不能重用，所以一个模板参数名在一个特定模板参数列表只能出现一次：

```cpp
// 错误 非法重用模板参数名
template <typename V, typename V> ...
```

#### 模板声明

模板声明必须包含模板参数：

```cpp
template<typename T> int compare(const T&, const T&);
template<typename U> class Blob;
template<typename Type> Type calc(const Type&, const Type&);
```

一个特定文件所用到的模板的声明一般都放在文件最开始的地方。也就是在使用这些模板前就一起声明好。

#### 使用类的类型成员

因为模板代码只有在实例化之后才能得知通过作用域运算符来访问的是`static`成员还是一个类型成员。

假如`Type`是个模板类型参数，当编译器处理`Type::mem`这样的代码的时候，它不知道`mem`到底是个类型成员还是`static`数据成员。

```cpp
Type::mem * p;		// mem是什么?
```

需要知道`*`可以用于表示指针或者进行乘法运算。如果`mem`是个可运算对象，并且`p`也是个可运算对象，那么就是`mem * p`将得到一个右值(假设)。

默认情况下，C++语言假定通过作用域运算符访问的名字不是类型。所以如果想用一个模板类型参数的类型成员，就必须要显示的告知编译器这个名字是个类型。可以用通过`typename`实现：

```cpp
template <typename Type>
typename Type::mem top(const Type& c)	// 通过typename告知编译器Type::mem是个类型 这是个返回Type::mem类型的函数
{
    if (!c.empty())
        return c.back();
    else
        return typename Type::mem();
}
```

#### 默认模板实参

如同默认实参，也可以提供**默认模板实参**(default template argument)。

C++11后，可以给函数和类模板提供默认实参，而更早的C++标准只允许为类模板提供默认实参。

```cpp
// compare有个默认模板实参less<T>和一个默认函数实参F()
template <typename T, typename F = less<T>>
int compare(const T &v1, const T &v2, F f = F())
{
    if (f(v1, v2)) return -1;
    if (f(v2, v1)) return 1;
    return 0;
}
```

调用：

```cpp
bool i = compare(0, 42);		// 使用less i为-1; T是int(0), int(42); F是less<int(T)>

// 结果依赖于item1和item2的isbn
Sales_data item1(cin), item2(cin);
bool j = compare(item1, item2, compareIsbn);
```

与函数默认实参相同，对于一个模板参数，只有在它右侧的所有参数都有默认实参时，它才可以有默认实参。

#### 模板默认实参与类模板

```cpp
template <class T = int> class Numbers      // T 默认是int
{
public:
    Numbers(T v = 0): val(v) { }
    // 对数值的各种操作
private:
    T val;
};

Numbers<long double> lots_of_precision;
Numbers<> average_precision;        // 空<>表示我们希望使用默认类型 其实也就是Numbers<int>
```

