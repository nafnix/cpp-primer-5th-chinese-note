[toc]

# 表达式

表达式由一个或者多个**运算对象**(operand)组成，对表达式求值将得到一个**结果**(result)。字面值和遍历是最简单的**表达式**(expression)，其结果就是字面值和变量的值。把一个**运算符**(operator)和一个或者多个运算对象组合起来可以生成较复杂的表达式。

## 基础

### 基础概念

C++定义了**一元运算符**(unary operator)和**二元运算符**(binary operator)。作用于一个运算对象的运算符是一元运算符，如取地址符`&`和解引用符`*`。如`==`和乘法`*`就是二元运算符。还有作用于三个运算对象的三元运算符。函数调用也是中特殊的运算符。

#### 组合运算符和运算对象

要理解含有多个运算符的复杂表达式要先理解运算符的**优先级**(precedence)、**结合律**(associativity)以及运算对象的**求值顺序**(order of evaluation)。

#### 运算对象转换

在表达式求值的过程中，运算对象常常由一种类型转成另一种类型。很多时候运算对象的类型不同也么事，只要它们可以被转换成同一种类型就ok。

小整数类型如bool、char、short常被**提升**(promoted)成较大的整数类型。

#### 重载运算符

C++语言定义了运算符作用在内置类型和复合类型的运算对象时候所要执行的操作。用户可以自定义运算符在作用在类类型的运算对象时候的含义。这种自定义的过程给运算符增加了另一种含义，称之为**重载运算符**(overloaded operator)。

IO库的 >>和<<以及string对象、vector对象和迭代器用的运算符都是重载运算符。

运算对象的类型和返回值的类型都是由重载运算符定义的，但是运算对象的个数、运算符的优先级和结合律都是无法改变的。

#### 左值和右值

**右值**(rvalue，读作are-value)、**左值**(lvalue，读作ell-value)。这俩词从C继承而来。

当一个对象被用作右值的时候，用的是对象的内容；当对象被用作左值的时候，用的是对象在内存中的位置。

右值(内容)不能当成左值(内存位置)来用，但左值可以当作右值来用。

可以理解为左值是一个具体的位置上的东西，但是我们通常叫左值的时候是叫左值的名字，我们知道左值代表哪个位置上的东西，但是右值就是一个名字，虽然他也有东西的含义，我们并不知道它到底在哪个位置，只知道他是个东西。

- 赋值运算符需要一个非常量左值作为左侧运算对象，得到的结果也是一个左值
- 取地址符作用于一个左值运算对象，返回一个指向该运算对象的指针，该指针是个右值。
- 内置解引用运算符、下标运算符、迭代器解引用运算符、string和vector的下标运算符的求值结果都是左值。
- 内置类型和迭代器的递增递减运算符作用于左值运算对象，其前置版本所得的结果也是左值。
- 使用关键字decltype的时候，左值和右值也有所不同。如果表达式的求值结果是左值，decltype作用于该表达式 (不是变量)得到一个引用类型。
  - 假设p的类型是`int*`，因为解引用符生成左值，所以`decltype(*p)`的结果是`int&`。另一方面，因为取地址运算符生成右值，所以`decltype(&p)`的结果是`&int`。因为取地址符生成右值，所以`decltype(&p)`的结果是`int**`，也就是说，结果是一个指向整形指针的指针。

### 优先级与结合律

**复合表达式**(compound expression)是指含有两个或者多个运算符的表达式。

如果运算符的优先级相同，将按照从左往右的顺序组合运算对象。

#### 括号无视优先级与结合律

```c++
cout << (6 + 3) * (4 / (2 + 2)) << enld;		// 使用括号避免了先乘除后加减规律
```

#### 优先级与结合律有何影响

```c++
int ia[] = {0,2,4,6,8};
in last = *{ia + 4};		// 把last初始化成8 也就是ia[4]的值 指针ia原本指向ia[0]的地址 然后移了4 也就指向 ia[4] 然后解引用解开内存地址 = 8
last = *ia +4 // ia指针指向ia[0] 然后取出值再加4 = 0+4 = 4
```

结合律对表达式产生的影响的典型案例

```c++
cin >> v1 >> v2;		// 先读入v1再读入v2
```

#### 练习

$5+10*20/2 = 105$

```c++
// 给下列表达式合适位置添加括号 使之添加括号后运算对象的组合顺序与添加括号前一致
*vec.begin()
*vec.begin() + 1

// 答案
*(vec.begin())			// .的优先级比解引用符* 高 所以给.中添加一个括号
(*(vec.begin())) + 1	// .的优先级比解引用符* 高 所以给.中添加一个括号 然后* 的优先级又比+高 所以再添个括号
```

### 求值顺序

优先级规定了运算对象的组合方式，但是没有说明运算对象按照什么顺序求值。

```c++
int i = f1() * f2();		// 虽然i能得到f1()与f2()相乘的值 但是我们不知道是f1先被调用还是f2现被调用
```

于没有指定执行顺序的运算符来说，如果表达式指向并且修改了同一个对象，就会引发错误并产生没有定义的行为。

例如<<运算符没有明确规定何时以及如何对运算对象求值

```c++
int i = 0;
cout << i << ' ' << ++i << endl;		// 未定义的 有两个表达式 cout只负责输出值但不会去运算
```

因为程序是未定义的，所以我们无法推断它的行为。编译器可能先求i的值也有可能先求++i的值。

有4种运算符明确规定了运算对象的求值顺序

1. 逻辑与`&&`运算符，规定先求左侧运算对象的值
2. 逻辑或`||`运算符，规定先求左侧运算对象的值(后面会学到)
3. 条件`?:`运算符，先算`?`左边的值，若其值为真，则算`:`左边的值，否则算`:`右边的值。(在后面将会学到)
4. 逗号`,`运算符，先算左边的值(在后面会学到)

#### 求值顺序、优先级、结合律

运算对象的求值顺序与优先级和结合律无关，在一条形如`f()+g()*h()+j()`的表达式中

- 优先级规定，`g()`的返回值和`h()`的返回值相乘
- 结合律规定，`f()`的返回值先和`g()`和`h()`的乘积相加，所得结果再和`j()` 的相加
- 对于函数的调用顺序没有明确规定。

若这4个函数是没有关系的函数，它们既不会改变其他任意一个函数的状态也不执行IO任务，那么函数的调用顺序不受限制。

若它们中某个函数会影响到其他任意一个函数，那么就是一条错误的表达式，将产生未知的行为。

1. 不确定执行顺序的时候最好用括号来强制让表达式的组合关系符合程序逻辑的要求。
2. 若改变了某个运算对象的值，在表达式的其他地方不要再用这个(被改过的)运算对象。

## 算术运算符

| 运算符 | 功能     | 用法          |
| ------ | -------- | ------------- |
| +      | 一元正号 | `+expr`       |
| -      | 一元负号 | `-expr`       |
| ∨      | ∨        | ∨             |
| *      | 乘法     | `expr * expr` |
| /      | 除法     | `expr / expr` |
| %      | 求余     | `expr % expr` |
| ∨      | ∨        | ∨             |
| +      | 加法     | `expr + expr` |
| -      | 减法     | `expr - expr` |

除非另做特殊说明，算术运算符都能做用于任意算术类型，以及任意能转换为算术类型的类型。算术运算符的运算对象和求职结果都是右值。

一元正号(没有负号)、加减运算符都能作用于指针。

一元负号运算符对运算对象值取负之后，返回其提升后的副本。

```c++
int i = 1024;
int k = -i;			// k = -1024
bool b = true; 
bool b2 = -b;		// b2 = true! 
```

对大多数运算符来说，布尔类型的运算对象被提升为int类型。如上所示，布尔变量b的值为真，参与运算时将被提升成整数值1，对它求负后的结果变成了-1，再将-1转为布尔值将其作为b2的初始值，-1不是0，所以结果还是true。

参与取余`%`的运算对象必须是整数类型

```c++
42 % 12;		// 正确 结果是6
42 % 3.14;		// 错误 运算对象是浮点类型 
```

在除法运算中，如果两个运算对象的符号相同则商为正(如果不为0的话)，否则商为负。C++语言的早期版本允许结果为负值的商向上或者向下取整，C++11新标准规定商一律向0取整(也就是直接丢弃小数的部分)。

根据取余运算的定义，如果m和n是整数而且n非0，则表达式`(m/n)*n+m%n`的求值结果与m相等。也就是说，如果m%n不是0，则它的负号和m相同。C++早期允许m%n的符号匹配n的负号，而且商向负无穷一侧取整，这一方式在新标准中已经被禁止了。除了-m导致溢出的特殊情况，其他时候`(-m)/n`和`m/(-n)`都等于`-(m/n)`，`m%(-n)`等于`m%n`，`(-m)%n`等于`-(m/n)`

```c++
21 % 6 == 3			// 21 / 6 = 3  -->  6 * 3 = 18  -->  21 - 18 = 3
21 % 7 == 0			// 21 / 7 = 3  -->  7 * 3 = 21  -->  21 - 21 = 0
-21 % -8 == -5		// -21 / -8 = 2-->  -8 * 2 = -16 ->  -21 - (-16) = -21 + 16 = -5
21 % -5 == 1		// 21 / -5 = -4-->  -5 * -4 = 20 ->  21 - 20 = 1
```

### 溢出和其他算术运算异常

算术表达式可能产生未定义的结果。一部分原因是数学性质本身：除数是0的情况；另一部分源于计算机的特点：例如溢出，当计算的结果超出该类型所能表示的范围时候就会产生溢出。

例如每个机器的short类型占16未，则最大的short数值是32767，在这台机器上，下面的复合赋值语句就会产生溢出

```c++
short short_value = 32767;		// short_value是short类型所能承载的最大值
short_value += 1;			   // 该计算导致溢出
cout << short_value << endl;
```

最后的`short_value`会输出什么？给short_value赋值的语句是未定义的，这是因为表示一个带符号数32768(32767+3)需要17位，但short类型只有16位。很多系统在编译和运行时都不报溢出错误，像其他未定义的行为一样，溢出的结果是不可预知的。不过它可能会输出

```c++
-32767
```

该值发生了"环绕(wrapped around)"，符号位本来是0，由于溢出被改成了1，于是结果变成了一个负值。在别的系统有可能有其他的结果，程序的行为可能不同甚至会导致崩溃。

### 练习

1. 写出下列表达式的求值结果

   1. ```
      -30 * 3 + 21 / 5 = -86
      -30 + 3 * 21 / 5 = -18
      30 / 3 * 21 % 5 = 0
      -30 / 3 * 21 % 4 = -2
      ```

2. 写出一条表达式用于确定一个整数是奇数还是偶数

   1. ```c++
      cin >> x;
      cout << bool(cin) << endl;
      ```

3. 溢出的含义是什么？写出三条将导致溢出的表达式

   1. 溢出指一个数超出它当前类型所能表达的范围

   2. ```c++
      // 1
      short v1 = 32767+1
      // 2
      unsigned v2 = 4294967295+1
      // 3
      int v3 = 4294967295;
      ```

## 逻辑和关系运算符

| 结合律 | 运算符 | 功能     | 用法           |
| ------ | ------ | -------- | -------------- |
| 右     | !      | 逻辑非   | `!expr`        |
| **∨**  | **∨**  | **∨**    | **∨**          |
| 左     | <      | 小于     | `expr < expr`  |
| 左     | <=     | 小于等于 | `expr <= expr` |
| 左     | >      | 大于     | `expr > expr`  |
| 左     | >=     | 大于等于 | `expr >= expr` |
| **∨**  | **∨**  | **∨**    | **∨**          |
| 左     | ==     | 相等     | `expr == expr` |
| 左     | !=     | 不相等   | `expr != expr` |
| **∨**  | **∨**  | **∨**    | **∨**          |
| 左     | &&     | 逻辑与   | `expr && expr` |
| **∨**  | **∨**  | **∨**    | **∨**          |
| 左     | \|\|   | 逻辑或   | `expr || expr` |

关系运算符作用于算术类型或指针类型，逻辑运算符作用于所有可以转成布尔值的类型。逻辑运算符和关系运算符的返回值都是布尔类型。这两类运算符的运算对象和求值结果都是右值。

### 逻辑与和逻辑或运算符

它俩都是先算左边再算右边，逻辑与左边不行整条表达式就都为false，逻辑或先算左边再算右边，左边不行就去右边，右边再不行就返回false，但是如果左边就行了就不算右边了。左侧运算对象无法确定表达式的结果时候才会算右边运算对象的值。这种策略称为**短路求值**(short-circuit evaluation)。

假定有个存储着若干string对象的vector对象，要求输出string对象的内容并且在遇到空字符串或者以句号结束的字符串时候进行换行。

```c++
int main(){
    vector<string> text{"abc.", "def","","ghi"};
    for (const string &s : text){			
        // s被声明成对常量字符串的引用 因为text的元素可能非常大 声明成引用类型可以避免对元素的拷贝 又因为不需要对string对象做写操作 所以s被定义成对常量的引用
        cout << s;
        if (s.empty() || s[s.size() - 1] == ' ')
            cout << endl;
        else
            cout << " ";
    }
}
```

#### 逻辑非运算符

`!`将运算对象的值取反后返回。

```c++
if (!vec.empty())
	cout << vec[0];
```

若vec为空则为真，又因为使用了`!`非运算符，所以结果取反，也就是最终为假，即不输出`vec[0]`。也就是有说成没有、没有说成有。

#### 关系运算符

比较对象的大小关系并返回布尔值

```c++
if (i < j < k)			// 若k大于1则为真 因为i < j得出一个0或者1的布尔值 然后再对比0or1 < k 的结果
// 正确比较方法
if (i < j && j < k)
```

#### 相等性测试与布尔字面值

若想测试一个算术对象或指针对象的真值，最直接的方法是将其作为if语句的条件

```c++
if (val){}
if (!val){}
```

有人会这样写

```c++
if (val==true){}
```

这种写法存在两个问题

1. 与原来的相比写法较长不直接
2. 若val不为布尔值，这样的比较就失去了原来的意义

若val不是布尔类型，那么会在比较前将true转为val的类型。也就是说如果val不是布尔值，应该写作如下

```c++
if (val == 1){}
```

也就是说再进行比较运算时候除非比较的对象是布尔类型，不然就别用布尔字面值true或者false，应该直接写作0或者1。

#### 练习

解释下述if语句中条件部分的判断过程

```c++
const char *cp = "Hello World";
if (cp && *cp);
```

> The first operand is true if `cp` is not a `nullptr`, the second operand is true if the dereferenced value of `cp` is not empty or zero. Due to the nature of the logical `AND` operator this code will not attempt to dereference a null pointer (it will short-circuit after failing the first evaluation). Since `cp` is a valid pointer (true) and `*cp` = `H` (true) the result of this statement is true.

大意 cp指针指向字符串字面值Hello World的地址! 若是对cp解引用得到的是该地址的第一个值 也就是H。所以可以得出

```c++
if ("Hello World!" && 'H');
```

为真

为while循环写个条件，使其从标准输入读取整数，遇到42时候停止

```c++
int a;
whlie(cin >> a; && a != 42)		// 先执行左边的cin >> a判断有无输入值 然后如果输入就判断a是否等于42
```

## 赋值运算符

`=`赋值运算符左侧必须是个可以被修改的左值。我们也要分清初始化和赋值的不同含义

若`=`左右两边的运算对象类型不同，则右侧运算对象的类型就会被转成左侧运算对象的类型。

下述均为非法赋值语句

```c++
1024 = k;			// 赋值运算符的左值必须是个可被修改的左值 而此次居然将字面值作为左值
i + j = k;			// 算术表达式只能是右值 此处的算术表达式作为左值使用 即使该程序不报错 后面我们到底应该用i还是j
```

C++11新增允许用花括号括起来的初始值列表作为赋值语句的右值

```c++
k = {3.14};		// 错误 窄化转换
vector<int> vi;	// 初始化为空
vi = {0,1,2,3,4,5,6};	// 正确 现在vi有7个元素了 从0到6
```

### 赋值运算满足右结合律

```c++
int ival, jval;
ival = jval = 0;		// ival 和 jval都被赋0
```

多重赋值语句的每个对象的类型与右边对象的类型相同、要不就可以从右边的对象的类型转换得到，如上所示，0是个字面值整数0，然后赋给jval，jval作为一个int型整数接收到0，此时jval内的值就是0，然后ival作为一个整数接收jval的值，也就是ival = 0

```c++
int ival, *pval;		// ival的类型是int pval的类型是指向int的指针
ival = pval = 0;		// 错误 pval是指针，不能将指针的值赋给int
string s1, s2;
s1 = s2 = "OK";			// 字符串字面值"OK"被转成string对象赋给s1
```

### 赋值运算优先级较低

```c++
// 形式繁琐 易出错的写法
int i = get_value();		// 得到第一个值
while (i != 42){
	// 其他处理...
	i = get_value();		// 得到剩下的值
}
```

首先调用get_value得到一个值，然后循环部分使用该值作为条件。在循环体中最后一条语句会再次使用get_value()函数并且不断重复循环。事实上我们有更好的写法

```c++
int i;
while((i = get_value()) != 42){
	// 其他处理...
}
```

直接在while条件中读取get_value的值赋给i，然后将该表达式的结果作为`!=`的左值判断是否等于42。若不加括号，因为在C++中`=`比`!=`的优先级低，那么执行顺序就变成先判断`get_value() != 42`然后再将其返回的布尔值`=`给`i`。就导致结果是判断`get_value()`的值是否等于42，如果不等于就为真然后赋给`i`，此时i就变成了一个布尔值0或者1，我们在循环体中可能需要使用i，但是此时i变成了一个布尔值，这就有违我们的初衷。

### 切勿混淆相等运算符和赋值运算符

C++语言允许用赋值运算作为条件，但是该特性可能带来意想不到的后果

```c++
if (i = j)			// j的值赋给了i
if (i == j)			// 判断i和j的值是否相等
```

### 复合赋值运算符

我们经常要对对象施以某种运算，然后把计算的结果再赋给这个对象。

求和程序

```c++
 int sum = 0;
 // 计算1到10间的和
 for (int val = 1; val <= 10; ++val)
 	sum += val; 
```

这种复合操作不仅对加法而言很常见，且也常用于其他算术运算符

如下是一些示例

```c++
+=	-=	*=	/=	%=		// 算术运算符	+= --> value = value + value2
<<=	>>=	&=	^=	|=		// 位运算符 将在后面学到
```

总之任何运算符都等于` a = a op b;`

与普通运算符的区别是左侧运算对象的求值次数，使用复合运算符只求值一次，使用普通运算符的求值次数是两次。两次包括将右子表达式的一部分求值，然后作为赋值运算的左侧运算对象求值。使用复合运算符对程序性能有些许影响之外区别可以忽略不计。

### 练习

1. 在下述语句中，当赋值完成后i和d的值分别是多少

   1. ```c++
      int i;double d;
      
      d = i = 3.5;		// i = 3; d = 3			i作为整数接收3.5 舍去小数部分变成3 d作为浮点型接收i的值3
      i = d = 3.5;		// d = 3.5; i = 3		d作为浮点数接收3.5 i作为整型接收d的值3.5 舍去小数部分等于接收3
      ```

2. 执行下述if语句后将发生什么

   1. ```c++
      if (42 = i)		// 非法 左值是个字面量
      if (i = 42)		// 若i是个可以正常接收整数的类型 那么就执行if为真后的语句 否则非法
      ```

3. 下面的赋值是非法的，为什么？应如何修改？

   1. ```c++
      double dval; int ival; int *pi;
      dval = ival = pi = 0;
      
      // 此处pi是个指向int的空指针 而ival和double都不是指针 所以非法
      // 若是想让ival和dval都接收0 那么可以将pi=0处转换成一个表达式
      /*
      dval = ival = (pi = 0) != nullptr;
      先将0赋给pi 使pi变成一个空指针 然后判断pi是否不是nullptr(空指针) 答案是否定的 所以返回一个布尔值0
      然后就变成了 dval = ival = 0(布尔值)
      此时pi是一个空指针
      */
      ```

4. 尽管下面的语句合法，但它们实际执行的行为可能和预期的不一样，为什么？应如何修改？

   1. ```c++
      if (p = getPtr() != 0)		
      // 赋值运算符比逻辑运算符的优先级更低 所以导致程序先算getPtr()是否不是0 然后再将返回的布尔值赋给p
      // if ((p = getPtr()) != 0)
      
      if(i = 1024)
      // 错误的使用了相等运算符
      // if (i == 1024)
      ```

## 递增和递减运算符

递增`++`递减`--`运算符为对象的加1和减1提供了一种简介的书写形式。这俩运算符还可以应用于迭代器，因为很多迭代器本身不支持算术运算，所以此时递增和递减运算符除了书写简洁外还是很有必要的。

递增递减运算符有俩种形式，一种前置一种后置。目前为止都是用的前置版本`++i`，前置版本的先将运算对象加1(或者减1)，然后把改变之后的对象作为求值的结果。后置版本也会把对象加以或者减一，不过求值结果是运算对象改变之前的副本。

```c++
int i = 0, j;
j = ++i;			// j = 1	i = 1		j 得到递增后的值 	前置版本	前置版本先算对象本身
j = i++;			// j = 1	i = 2		j 得到递增前的值	后置版本 	后置版本等要操作的运算操作完成后再算对象本身
```

这两种运算符必须用左值运算对象，

前置版本将对象本身作为左值返回，

后置版本把对象原始值的副本作为右值返回。

**建议是：除非是必要的情况，否则就不要用后置版本**

前置版本的递增运算符避免了不必要的工作，它把值加1之后直接返回改变了的运算对象

后置版本需要先将原始值存储下来以便于返回这个还没有被修改过的内容。如果我们不需要修改前的值，那么后置版本的操作就是一种资源浪费。

于整数和指针类型而言，编译器可能对这种额外的工作进行一定的优化。但是，于相对复杂的迭代器类型，这种额外的工作就消耗巨大了。所以我们最好尽量使用前置版本，这样就不用担心性能为你，且更重要的是写出的代码能更加符合编程的初衷。

### 在一条语句中混用解引用和递增运算符

若我们想在一条复合表达式中既将变量加1或者减1又能使用它原来的值，这时候就能用递增和递减运算符的后置版本。(不是刚说尽量别用。。)

示例，使用后置版本来控制循环输出一个vector对象内容直至遇到(不包括)第一个负值为止

```c++
auto pbeg = v.begin();		// 创建迭代器输出元素直至遇到第一个负值为止
while (pbeg != v.end() && *pbeg >= 0)
    cout << *pbeg++ << endl;
```

后置递增运算符优先级高于解引用运算符，因此`*pbeg++`可理解为`*(pbeg++)`。pbeg++把pbeg的值加1，然后返回pbeg的初始值的副本作为其求值结果，此时解引用运算符的运算对象是pbeg没有增加之前的值。再执行完`cout << *pbeg++ << endl;`之后`pbeg`指针指向下一个位置。

**建议：简洁可以成为一种美德**

形如`*pbeg++`的表达式可能一开始不太容易理解，但其实这是一种被广泛使用的有效写法。当对这种形式熟悉之后，书写

```c++
cout << *i++ << endl;
```

要比下面这种等价语法更加简洁，更少出错。

```c++
cout << *i << endl;
++i;
```

### 运算对象可按任意顺序求值

大多运算符没规定运算对象的求值顺序，这在一般情况下不会有什么影响。但是如果某条子表达式改变了某运算对象的值，且正巧另外一条表达式又要用这个值的话，运算对象的求值顺序就很关键了。因为递增递减运算符会改变运算对象的值，所以要提防在复合表达式里面错用这两个运算符。

```c++
for (auto it = s.begin(); it != s.end && !isspace(*it);	++it)
	*it = toupper(*it);			// 将当前字符改为大写 
```

上述程序中，我们将解引用it和递增it两项任务分开完成。但是如果我们试图用一个看似等价的while来实现

```c++
while (beg != s.end() && !isspace(*beg))
	*beg = toupper(*beg++);			// 错误
```

这种循环的结果是没有定义的。问题在于：赋值运算符左右两端的运算对象都用到了beg，且右侧的运算对象还改变了beg的值，所以该赋值语句是未定义的。编译器可能按照下面的任意一种思路处理这个表达式

```c++
*beg = toupper(*beg)		// 若先求左边的值

*(beg + 1) = toupper(*beg);	// 如果先求右边的值
```

也有可能采用别的什么方式去处理

### 练习

假设`ptr`的类型是指向`int`的指针、`vec`的类型是`vector<int>`、`ival`的类型是`int`，说明下面的表达式是何含义？如果有表达式不正确，为什么？应该如何修改？

1. ```c++
   // a
   ptr != 0 && *ptr++
   // 先算&&左边的 这是固定的 左边不符合才会算右边 所以我们先看ptr!=0
   // 首先测试 ptr != 0 即先算ptr是否指向一个字面常量0(是否是个空指针)  如果ptr不是空指针 就返回true
   // 此时就变成 true && *ptr++ 也就是 *ptr++
   // *ptr++ ptr指向的值是否是0或者ptr本身是个空指针 若是0就返回false 若有值就返回true
   // 也就是 true && true
   // 在执行完之后指针移位 移到下个位置
       
   /*
   借助以下程序帮助理解
   int main(){
       int t = 0;
       int *ptr = &t;				// ptr指针指向t ptr不是空指针
       if (ptr != 0 && *ptr++){	 // ptr不是空指针 所以 ptr!=0-->true && *ptr是0所以false 也就是 true && false
       						   // 但是*ptr后还有个++ 但是这是个后置递增 所以在下次比较时候的 *ptr的状态是 *(ptr+1)
       						   // *(ptr+1)只是形容指针移位的状态 也就是ptr不再指向t 而是指向一个未知的地方
           cout << ptr;
       }else if (*ptr){			// 因为已经将 *ptr移动到一个新的地址 不再指向t 所以此处解引用ptr的结果 要看ptr指向的那个新的地址的值是否为0
           cout << "ptr解引用后得到: " << *ptr << endl;
           cout << "t: " << t << endl;		// 此处为了表明*ptr++修改的不是t的值 我们还可打印一下t的值
       }
       else{
           cout << *ptr << endl;
           cout << "t: " << t << endl;		// 此处为了表明*ptr++修改的不是t的值 我们还可打印一下t的值
       }
       system("pause");
       return 0;
   }
   */
   // 醉了 指针移位
   ```

2. ```c++
   // b
   ival++ && ival
   // 判断ival是否不是0 如果不是就可以理解成 true && (ival+1)
   // 若ival的值不是-1 那么理所当然的就是 true && true
   // 总之就题目给出的条件ival是个int型的数 那么无论ival是啥这条表达式都必然为真
   // 但是为了理解 更好的写法是 ival && ival+1
   ```

3. ```c++
   // c
   vec[ival++] <= vec[ival]
   // 因为没有规定运算顺序所以可能先求出左边的值再求出右边的值 或者先求右边的值再求左边的值
   // 即 可能有两种结果
   /*
   第一种
   先求左边的值再求右边的值
   那么实际的运算也就变成了下面这样(对于从左往右的理解顺序)
   vec[ival] <= vec[++ival]
   判断vec的第ival数位置的值是否小于或者等于 vec的第ival数+1位置的值
   */
   
   /*
   第二种
   先求右边再求左边
   那么其实也就变成
   vec[ival] <= vec[ival]
   答案是肯定的 vec[ival]的值必然等于vec[ival]
   但是再比较完成之后ival的值还会自增1
   */
       
   // 更好的解决方法(照正常人理解这条表达式的思路解决)
   // 因为ival在题目中说了是个int 那么直接在右侧中的ival+1就行了
   // vec[ival] <= vec[ival+1]
   ```

## 成员访问运算符

点运算符和箭头运算符都可以用于访问成员，其中，点运算符获取类对象的一个成员；箭头运算符与点运算符有关，表达式`ptr->mem`也就是`(*ptr).mem`

```c++
string s1 = "a string", *p = &s1;
string::size_type n = s1.size();		// 书上用auto替代了string::size_type 运行string对象s1的size成员
n = (*p).size();					   // 运行p所指对象的size成员
n = p->size();						   // 等价于(*p).size()
```

也就是去掉了解引用符还有将点运算符换成箭头运算符。

因为解引用运算符的优先级低于点运算符，所以在使用点运算符的时候要将解引用运算的子表达式括起来。不加试试：

```c++
*p.size();				// p是个指针，指向一个地址，地址本身没有size成员 地址上的值才有
```

箭头运算符作用于一个指针类型的运算对象，结果是个左值。点运算符分成两种情况：

1. 若成员所属的对象是左值，那么结果就是左值
2. 若成员所属的对象是右值，那么结果就是右值

> 回顾左右值笔记：
> 当一个对象被用作右值的时候，用的是对象的内容；当对象被用作左值的时候，用的是对象在内存中的位置。
> 右值(内容)不能当成左值(内存位置)来用，但左值可以当作右值来用。

## 条件运算符

条件运算符`?:`允许我们把简单的`if-else`逻辑嵌入到单个表达式中，条件运算符使用格式

```c++
cond?expr1:expr2;
```

其中cond是判断条件的表达式，而expr1和expr2是两个类型相同或可能转换为某个公共类型的表达式。

执行过程：

1. 先求cond的值，若条件为真则对expr1求值并返回该值
2. 若cond为假则对expr2求值并返回该值

示例使用条件运算符判断成绩是否合格

```c++
string finalgrade = (grade < 60) ? "fail" : "pass";
```

### 嵌套条件运算符

可以在条件运算符里面嵌套另外一个条件运算符。

示例使用条件运算符判断成绩是优秀、合格、不合格

```c++
finalgrade = (grade > 90) ? "high pass"
					    : (grade < 60) ? "fail" : "pass";
```

若分数`grade`大于90分，则将`"high pass"`赋给`finalgrade`，否则判断`grade`是否小于60，如果是，就将`"fail"`赋给`finalgrade`，如果不是，就将`"pass"`赋给`finalgrade`。

条件运算符的嵌套最好不要超过三层，否则将使得程序难以理解

### 在输出表达式中使用条件运算符

条件运算符的优先级很低，因此在一条长表达式中嵌套了条件运算子表达式的时候，通常需要在它两端加上括号。例如，有时需要根据条件值输出俩对象中的一个，如果没有加括号就完蛋了。

```c++
cout << ((grade < 60) ? "fail" : "pass");		// 输出pass或者fail
cout << (grade <60) ? "fail" : "pass";			// 输出1或者0
cout << grade < 60 ? "fail" : "pass";			// 错误 尝试比较cout和60
```

在第二条表达式中，grade和60的比较结果是`<<`运算符的运算对象，因此如果`grade<60`为真输出1，否则输出0.`<<`运算符的返回值是cout，接下来cout作为条件运算符的条件。也就是说第二条条件运算符等价于

```c++
cout << (grade < 60);		// 输出1或者0
cout ? "fail" : "pass";		// 根据cout的值是true还是false产生对应的字面值
```

而第三条条件运算符等价于下面的语句，所以是错误的

```c++
cout << grade;					// 小于运算符的优先级低于条件运算符，所以先输出grade
cout < 60 ? "fail" : "pass";	 // 然后比较cout和60
```

### 练习

1. 编写一段程序，使用条件运算符从`vector<int>`中找到哪些元素的值是奇数，然后将这些奇数值翻倍。

   1. ```c++
      int main(){
          std::vector<int> v{1,2,3,4,5};
          for (vector<int>::size_type a : v)
              cout << (a%2 ? a*2 : a) << ' ';
          system("pause");
          return 0;
      }
      ```

## 位运算符

位运算符作用于整数类型的运算对象，并把运算对象看成是二进制位的集合。位运算符提供检查和设置二进制位的功能

| 运算符 | 功能   | 用法             |
| ------ | ------ | ---------------- |
| `~`    | 位求反 | `~ expr`         |
| ∨      | ∨      | ∨                |
| `<<`   | 左移   | `expr1 << expr2` |
| `>>`   | 右移   | `expr1 >> expr2` |
| ∨      | ∨      | ∨                |
| `&`    | 位与   | `expr & expr`    |
| ∨      | ∨      | ∨                |
| `^`    | 位异或 | `expr ^ expr`    |
| ∨      | ∨      | ∨                |
| `|`    | 位或   | `expr | expr`    |

一般来说，若运算对象是"小整型"，则它的值会被自动提升成较大的整型类型。运算对象可以是带符号的，也可以是无符号的。如果运算对象是带符号的且它的值为负，那么位运算符如何处理运算对象的"符号位"依赖于机器。且，此时的左移操作可能会改变符号位的值，因此是一种未定义的行为。

关于符号位如何处理没有明确的规定，所以最好是把位运算符用于处理无符号类型。

### 移位运算符

以往在处理输入和输出操作的时候已经使用过标准IO库定义的`<<`和`>>`运算符的重载版本。这两种运算符的内置含义是对其运算对象执行基于二进制位的移动操作，首先令左侧运算对象的内容按照右侧运算对象的要求移动指定位数，然后将经过移动的(可能还进行了提升)左侧运算对象的拷贝作为求值结果。其中右侧的运算对象一定不能为负，且值必须严格小于结果的位数，否则就会产生没有定义的行为。二进制位或者向左移`<<`或者向右移`>>`，移出边界之外的位就被舍弃掉了。

#### 如下示例

右侧为最低位且假定 `char`类型占8位、`int`型占32位

```c++
unsigned char bits = 0233;		// 0233是八进制的字面值 对应二进制数位 10011011


bits << 8		// 因为char是小整型 所以会被提升成较大的整型类型int 然后因为是左移运算符<< 所以如下所示
00000000 00000000 10011011 00000000
// 因为被提升成int 原本因是 00000000 00000000 00000000 10011011 但是被左移了8位

将其重置为 unsigned char bits = 0233;
bits << 31		// 向左移动31位 最左边的几位超出边界所以被舍弃了
10000000 00000000 00000000 00000000
// 1001101[<-del]10000000 00000000 00000000 00000000	[<-del]表示被舍弃的

bits >> 3		// 向右移动3位 因为原本就是在最右边 所以最低位的3个被舍弃
00000000 00000000 00000000 00010011[del->]011
```

**左移运算符`<<`**在右侧插入值为0的二进制位。**右移运算符`>>`**的行为则在于其左侧运算对象的类型：若该运算对象是无符号类型，在左侧插入值为0的二进制位；否则如果是有符号类型，在左侧插入符号位的副本或值为0的二进制位，如何选择要根据具体的环境而定。

### 位求反运算符

**位求反运算符`~`**将运算对象一个一个求反之后生成一个新的值。将0变成1，1变成0

```c++
unsigned char bits = 0227;		// 10010111

~bits		// 不执行位求反之前应该是 00000000 00000000 00000000 10010111
11111111 11111111 11111111 01101000
```

`char`类型的运算符先被提升成`int`类型，提升时运算对象原来的位还保持不变，往高位(左边)(high order position)添加0即可。

因此本例中，先将bits提升成int类型，然后往高位加24个0，随后将提升后的值逐位求反。

### 位与、位或、位异或运算符

- 与`&`运算符
- 或`|`运算符
- 异或`^` 运算符

这三个运算符在两个运算对象逐位执行相应的逻辑操作如下

```c++
unsigned char b1 = 0145;		// 01100101
unsigned char b2 = 0257;		// 10101111

b1 & b2		     // 24个高阶位都是0 00100101
b1 | b2 	     // 24个高阶位都是0 11101111
b1 ^ b2		     // 24个高阶位都是0 11001010
```

- 对于**位与运算符`&`**而言，若两个运算对象的对应位置**都是**1，那么运算对象中那个位置就是1，否则就是0
- 对于**位或运算符`|`**而言，若两个运算对象的对应位置**至少有**一个是1，那么那个位置就是1，否则就是0
- 对于**位异或运算符`^`**而言，如果两个运算对象的对应位置**只有**一个是1，那么就是1，否则就是0

### 使用位运算符

使用例子：设某班有30个学生，老师每周为学生进行一次测试，测试的结果只有通过或者不通过。为了更好地追踪测验的结果，我们可以使用一个二进制位代表某个学生在一次测验中是否通过，那么显然全班的测试结果可以用个无符号整数表示：

```c++
unsigned long quiz1 = 0;		// 将此值当作位的集合使用
```

定义`quiz1`位`unsigned long`使得`quiz1`在任何机器上都最少是32位；再给其赋一个初始值使得它在每一位一开始时就有统一且固定的值。

教师必须有权设置并检查每个二进制位。如，我们需要对序号27的学生对应的位进行设置通过测试。那么就该先创建个值，该值只有27位是1其他都是0，然后将该值与`quiz1`进行位或运算，这样就可以把`quiz1`第27位设为1，其它不变。

步骤：将`quiz1`低阶位赋0，下一位赋1，类推最后统计`quiz1`各个位的情况。

使用左移运算符和一个`unsigned long`类型的整数字面值1就能得到一个表示学生27通过了测试的数值

```c++
// 1UL << 27 生成一个值 该值只有第27位为1
// 1UL << 27 此表达式通过在值为1的那个二进制位后添加0 使得它向左移动了27位
// 再将1UL所得的值与quiz1进行位或运算 为了同时更新quiz1所以使用复合赋值语句
quiz1 |= 1UL << 27;
// quiz1 = quiz1 | (1UL << 27)


/*
int main(){
    unsigned long quiz1 = 0;
    quiz1 |= 1UL << 27;
    system("pause");
    return 0;
}
*/
```

若要将27学生设为未通过测试，那么只要使用异或运算符就可

```c++
quiz1 &= ~(1UL << 27);
```

最后再尝试检查学生27的测试情况

```c++
bool status = quiz1 & (1UL << 27);
// 将一个只有第27位为1的值与测试成绩quiz1按位求与，若quiz1的第27位是1，那么就是非0(true)，否则0(false)
```

### 移位运算符(IO运算符)满足左结合律

```c++
cout << "hi" << " there" << endl;
// 相当于 ((cout << "hi") << "there") << endl;
```

移位运算符的优先级：

- 比算术运算符低
- 比关系、赋值、条件运算符的优先级高

```c++
cout << 42 + 20;		// 正确 <<比+的优先级低 先得出 42+20的结果再执行<<
cout << (10 < 42);		// 正确 虽然<的优先级比<<低 但是人家加了括号
cout << 10 < 42;		// 错误 试图比较cout和42? 程序会理解为(cout << 10) < 42;
```

## sizeof运算符

sizeof运算符返回一条表达式或者一个类型名字所占的字节数。sizeof运算符满足右结合律，其所得的值是个`size_t`类型的常量表达式。

```c++
// 运算符的运算对象的两种形式
sizeof（type)
sizeof expr
```

`sizeof expr`返回的是表达式结果类型的大小。`sizeof`不实际计算其运算对象的值

```c++
Sales_data data, *p;
sizeof(Sales_data);		 // 存储Sales_data类型的对象所占的空间大小
sizeof data;			// data的类型的大小 即sizeof(Sales_data)
sizeof p;				// 指针所占用的空间的大小
sizeof *p;				// p所指指向的位置的空间大小 其实也就是sizeof(Sales_data)
sizeof data.revenue;	 // Sales_data的revenue成员对应类型的大小
sizeof Sales_data::revenue;	// 另外一种获取revenue成员对于类型大小的方式
```

因为sizeof满足右结合律且和`*`的优先级相同，所以表达式按照从右到左的顺序组合，也就是说`sizeof *p`与`sizeof(*p)`相同。然后因为`sizeof`不会实际求运算对象的值，所以即使`p`是个无效(没有初始化)的指针也没问题。于`sizeof`而言运算对象中解引用一个无效指针还是种安全的行为，因为指针实际上没被真正使用。`sizeof`不需要真的解引用指针也能知道它所指对象的类型。

C++11新增允许我们使用作用域运算符来获取类成员的小。大多时候只有通过类的对象才可以访问到类的成员，但是`sizeof`运算符无须我们提供一个具体的对象，因为要想知道类成员的大小不需要真的获取那个成员。`sizeof`运算符的结果部分依赖于其作用的类型：

- 对`char`或者类型为`char`的表达式执行`sizeof`运算，结果得1
- 对引用类型执行`sizeof`运算得到被引用对象所占空间的大小
- 对指针执行`sizeof`运算得到指针本身所占空间的大小
- 对解引用指针执行`sizeof`运算得到指针指向的对象所占用空间的大小，指针无需有效。
- 对数组执行`sizeof`运算得到整个数组所占用空间的大小，也就是对数组中的每个元素执行一次`sizeof`运算并把所有结果求和。`sizeof`不会把数组转成指针处理
- 对`string`对象或`vector`对象执行`sizeof`运算只会返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间

可以用数组的大小除意单个元素的大小得到数组中元素的个数：

```c++
// sizeof(ia)/sizeof(*ia)返回ia的元素个数
constexpr size_t sz = sizeof(ia)/sizeof(*ia);
int arr2[sz];		// 正确 sz返回一个常量表达式
```

### 练习

判断下面代码的输出结果并说明理由。

```c++
int x[10]; int *p = x;
cout << sizeof(x)/sizeof(*x) << endl;		// 10
cout << sizeof(p)/sizeof(*p) << endl;		// 2 
// p指针指向数组x的第一个&x[0] 因为x是int类型 所以2实际上是int的字节长度 2即是2个字节 2*8=16 16位
```

## 逗号运算符

**逗号运算符**(comma operator)含有两个运算对象，按照从左向右的顺序依次求值。和逻辑与、逻辑或、条件运算符一样，逗号运算符也规定了运算对象求值的顺序。

逗号运算符先算左侧的表达式，然后把左侧表达式的结果丢掉。逗号运算符真正的结果是右侧表达式的值。若右侧对象是左值，那么最终的求值结果也是左值

```c++
vector<int>::size_type cnt = ivec.size();
// 将把从size到1的值赋给ivec的元素
for(vector<int>::size_type ix = 0; ix != ivec.size(); ++ix, --cnt)
	ivec[ix] = cnt;
```

这个循环在for语句的表达式中递增ix、递减cnt，每次循环迭代ix和cnt相应改变。

只要ix满足条件，我们就把当前元素设成cnt的当前值。

## 类型转换

如果两种类型可以**相互转换**(conversion)，那么它们就是关联的。

```c++
// 下面表达式目的将ival初始化成6
int ival = 3.541 + 3;
```

程序会报出警告，该运算损失了精度。

两个运算对象类型不同。C++语言不会直接把两个不同类型的值相加，会根据类型转换规则设法把运算对象的类型统一之后再求值。上述的类型转换是自动执行的。它们被称为**隐式转换**(implicit conversion)

算术类型间的隐式转换被设计得尽可能避免损失精度。大多时候若同时有整数对象和浮点数对象，整型会被转成浮点型。如上述例子3就被转成了浮点型。也就是实际上`3.541 + 3`实际上得到的是浮点数。

### 何时发生隐式类型转换

下列情况中，编译器会自动转换运算对象的类型

- 在大多数表达式中，比int类型小的整型值首先被提升成较大的整数类型
- 在条件中，非布尔类型转换成布尔类型
- 初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型
- 如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型
- 后面将会提到，函数调用时侯也会发生类型转换

### 算术转换

**算术转换** (arithmetic conversion)的含义是把一种算术类型转换成另外一种算术类型。普遍情况下，会被转成较宽的类型。当表达式中既有浮点类型也有整数类型时候，整数值将转换成相应的浮点类型。

#### 整型提升

**整型提升**(integral promotion)负责把小整数类型转换成较大的整数类型。于`bool`、`char`、`signed char`、`unsigned char`、`short`等类型而言，只要它们的值可以存在`int`中，就会被提升成`int`。

提升的前提是转换后的类型要能够容纳原类型所有可能的值。

#### 无符号类型的运算对象

若某个运算符的运算对象类型不一致，那就会被转成同一种类型。但是如果某个运算对象的类型是无符号类型，那么转换的结果就依赖于机器中各个整数类型的相对大小了。

如果两个运算对象的类型大小相同，但是一个有符号一个无符号，那么有符号就会被转成无符号。若有符号类型的值刚好是负值，那么就会取模。即表示数值总数取模后的余数。

> 当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。例如8比特大小的`unsigned char`可能表示0至255间的额值，如果我们赋了一个0至255之外的值，则实际的结果是该值对256取模后所得的余数。因此，把`-1`赋给8比特大小的`unsigned char`所得的结果是255。也说明如果取模后的值是0，那么再将此值赋给布尔类型那么布尔类型也会得到false，虽然看着不是0但是就是0。

若两个运算对象中，有符号类型比无符号类型的大，那么转换结果依赖于机器。若无符号类型的所有值能存在该带符号类型中，则无符号类型的运算对象转换成带符号类型。如果不能，那么带符号类型的运算对象转换成无符号类型。

例如，`long`和`unsigned int`，`unsigned int`和`long`的大小相同，则`long`类型的运算对象转成`unsigned int`类型；但是若`long`类型的对象占用空间比`unsigned int`大，则`unsigned int`类型的运算对象转换成`long`类型。

#### 理解算术运算

```c++
bool 	flag;		char 			cval;
short 	sval;		unsigned short 	 usval;
int 	ival;		unsigned int 	 uival;
long 	lval;		unsigned long	 ulval;
float 	fval;		double 			dval;


3.14159L+'a';		// 'a'提升成int，然后将int值转换成long double
dval + ival;		// ival 转成 double
dval + fval;		// fval 转成 double
ival = dval;		// dval 转成 int(去除小数)
flag = dval;		// 若dval是0 则flag是false 否则flag是true
cval + fval;		// cval 提升成 int 然后将int值转成float
sval + cval;		// sval 和 cval 都提升成int
cval + lval;		// cval 转换成 long
ival + ulval;		// ival 转换成 unsigned long
usval + ival;		// 根据 unsigned short 和 int 所占空间的大小进行提升
uival + lval;		// 根据 unsigned int 和 long 所占空间的大小进行转换
```

### 其它隐式类型转换

**数组转换成指针**：在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针

```c++
int ia[10];
int* ip = la;		// ia转成指向数组首元素的指针
```

当数组被用作decltype关键字的参数，或者作为取地址符`&`、`sizeof`等运算符的运算对象时，上述转换不会发生。同样的，如果用一个引用来初始化数组，上述转换也不会发生(实际上不可以用引用来初始化数组)。

**指针的转换**：C++规定几种其他的指针转换方式，包括：

- 常量整数值0或者字面值nullptr能转换成任意指针类型；
- 指向任意非常量的指针能转换成`void*`；
- 指向任意对象的指针能转换成`const void*`

**转换成布尔类型**：存在一种从算术类型或指针类型向布尔类型自动转换的机制。如果指针或算术类型的值为0，结果为false，否则true：

```c++
char *cp = get_string();
if (cp) /*...*/		// 若指针cp不是空指针(指向0) 条件为真
while(*cp) /*...*/	// 若*cp不是空字符 条件为真
```

**转换成常量**：允许将指向非常量类型的指针转换成指向相应的常量类型的指针，对于引用也是如此。

也就是说，若T是一种类型，那么我们就能把指向T的指针或者引用粉笔额转换成指向const T的指针或者引用：

```c++
int i;
const int &j = i;		// 非常量转换成const int的引用
const int *p = &i;		// 非常量的地址转换成const的地址
in &r = j, *q = p;		// 错误 不允许将const转成非常量
```

相反的转换不存在，也就是说已经是const常量的不能再转成变量，即不能删除底层const。

**类类型定义的转换**：类类型能定义由编译器自动执行的转换，不过编译器每次只能执行一种类类型的转换。如果同时提出多个转换请求，那么这些请求会被拒绝。

已经使用过类类型转换：

```c++
string s, t = "a value";		// 字符串字面值转换成string类型
while (cin >> s)			   //  while的条件部分把cin转换成布尔值
```

IO库定义了从iostream向布尔值转换的规则，根据该规则，cin自动转换成布尔值。所得的布尔值到底是啥由输入流的状态决定。

### 显式转换

有时我们希望显示地把对象强制转成另外一种类型。

```c++
int i, j;
double slope = i/j;
```

就要使用某种方法将i和j显式地转换成double，这种方法称为**强制类型转换**(cast) 

这种方法本质上非常危险的。

#### 命名的强制类型转换

格式

```c++
cast-name<type>(expression);
```

 其中，`type`是转换得目标类型而`expression`是要转换的值。若`type`是引用类型，则结果是左值。`cast-name`是`static_cast`、`dynamic_cast`、`const_cast`、`reinterpret_cast`中的一种。`dynamic_cast`支持运行时类型识别。`cast-name`制定了执行的是哪种转换。

##### static_cast

任何具有明确定义的类型转换，只要不包含底层`const`，都可以使用`static_cast`。

例如，将一个运算对象强制转成double类型就能使得表达式执行浮点数除法：

```c++
double slope = static_cast<double>(j) / i;
```

常用于把一个较大的算术类型赋值给较小的类型时。通常如果编译器发现一个较大的算术类型试图赋值给较小的类型，就会给出警告信息，但如果用了显示转换，便是表明我们不在乎精度损失，警告就没了。

`static_cast`对于编译器无法自动执行的类型转换也很有用。可以用它来找回存在于`void*`的指针中的值

```c++
void* p = &d;		// 正确 任何非常量对象的地址都能存入void*
double *dp = static_cast<double*>(p);	// 将void*转回出事的指针类型
```

强制转换的结果会与原来的地址值相同，所以我们必须确保转换后所得到的类型就是指针所指的类型，就上述代码看，`&d`原先得是`double`类型。类型不符，就导致意想不到的后果。

##### const_cast

`const_cast`只能改变对象的底层`const`。且也只有`const_cast`能改变对象的底层`const`。

```c++
const char *pc;
char *p = const_cast<char*>(pc);		// 正确 但是通过p写值是未定义的行为
```

将常量对象转成非常量的行为称为"去掉`const`性质(cast away the const)"。一旦我们去掉了某个对象的const性质，编译器就不会再阻止我们对这个对象进行写操作了。如果对象本身不是一个常量，使用强制类型转换获得写权限是合法的行为(莫名其妙?)。若对象是个常量，再用`const_cast`执行写操作就会产生未定义的行为。

`const_cast`常用于有函数重载的上下文中。

##### reinterpret_cast

`reinterpret_cast`通常为运算对象的位模式提供较低层次上的重新解释。示例如下：

```c++
int *ip;
char *pc = reinterpret_cast<char*>(ip);
```

`pc`所指是个数字而不是字符，若把`pc`当成普通的字符指针使用就可能在运行时候发生错误：

```c++
 string str(pc);
```

使用`reinterpret_cast`是==**很危险的**==，用`pc`初始化`str`的例子很好地证明了这一点。其中的关键问题是类型改变了，但编译器没有给出任何警告或者错误的提示信息，编译器认为这种显式的转换是合法的。上述例子中虽然用`pc`初始化`str`没什么实际意义，甚至可能引发严重的后果，但是从语法上说这种操作也没什么。查找这类问题贼鸡二男，若将`ip`转换成`pc`的语句和用`pc`初始化`string`对象的语句分属在不同的文件就更加男了。

**`reinterpret_cast`本质上依赖于机器。要想安全地使用`reinterpret_cast`必须对涉及的类型和编译器实现转换的过程都非常了解。**

#### 尽量避免强制类型转换

**在有重载函数的上下文里面使用`const_cast`无可厚非，但在其他情况下使用`const_cast`就意味着程序存在某种设计缺陷。其他强制类型转换像`static_cast`、`dynamic_cast`都不应该频繁使用。每次写了一条强制类型转换语句，就应该去想想能不能用其它的方式实现相同的目标。就算实在没办法避免也该尽量限制类型转换值的作用域，并且记录对相关类型的所有假定，这样可以减少错误发生的机会。**

#### 旧式的强制类型转换

早期C++版本中，显示地进行强制类型转换包含两种形式：

```c++
type(expr);			// 函数形式的强制类型转换
(type) expr;		// C语言风格地强制类型转换
```

根据所涉及到的类型不同，旧式地强制类型转换分别具有与`const_cast`、`static_cast`、`reinterpret_cast`相似地行为。当我们在某处执行旧式地强制类型转换时，如果换成`const_cast`和`static_cast`也合法，那么这个行为和对应地命名转换相同。如果替换不合法，则旧式强制类型转换执行与`reinterpret_cast`类似的功能。

```c++
char *pc = (char*) ip;		// ip是指向整数的指针 该效果与使用reinerpret_cast一致
```

### 练习

假设i是int类型，d是double类型，书写表达式i*=d使其执行整数类型的乘法而非浮点类型的乘法

```c++
i*=d
i = i * d
int = int * double
执行整数类型的乘法
int = int * static_cast<int>(double)
i = i * static_cast<int>(d)
i*=static_cast<int>(d)
```

用命名的强制类型转换改写下列旧式的转换语句

```c++
int i; double d; const string *ps; char *pc; void *pv;

// a	pv = (void*)ps;
pv = const_cast<string*>(ps);		// pv是空指针所以无关类型 但是要将其去掉const性质

// b	i = int(*pc)
i = static_cast<int>(*pc);			// 因为只有pc是指针 i只是拿个值所以解引用加在pc上
    
// c 	pv = &d;
pv = static_cast<void*>(&d);		// pv也要变成空指针 指向和d一样的地址

// d	pc = (char*) pv;
pc = reinterpret_cast<char*>(pv);	// pv是空指针 使用reinterpret_cast将其在位模式重新解释 危险行为 
```