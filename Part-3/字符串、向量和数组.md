# 字符串、向量和数组

string 表示可以变长的字符序列，vector 存放的是某种给定类型对象的可变长序列。

## 命名空间的 using 声明

`std::cin` 表示从标准输入中读取内容。此处使用作用域操作符 `::` 的含义是：编译器从操作符左侧名字所示的作用域中寻找右侧那个名字。也就是使用命名空间 `std` 中的名字 `cin`。

使用`using`声明**(using declaration)就无须专门的前缀(不需要使用 `::` 了)。

```c++
using namespace::name;		// 声明语句
```

一旦使用了声明语句就能直接访问命名空间的名字

```c++
#include <iostream>
// using声明，当我们使用名字cin时，从命名空间std中获取它
using std::cin;
int main(){
	int i;
    cin >> i;
    cout << i;			// 错误，没有对应的using声明
    std::cout << i;		// 正确
    return 0;
}
```

#### 每个名字都需要独立的 using 声明

```c++
#include <iostream>
// #include <string>

using std::cin;
using std::cout;using std::endl;
int main(){
    int ret = 0;
    cout << "123" << endl;
    cin >> ret;
    return ret;
}

```

#### 头文件不应包含 using 声明

位于头文件的代码一般不应该使用 using 声明。因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件里有某个 using 声明，那么每个使用了该头文件的文件就都会有这个声明。对于某些程序来说，由于不经意间包含了一些名字，反而可能产生始料未及的名字冲突。

#### 一些注意事项

后面的所有例子将假设用到的标准库中的名字都已经使用 using 语句声明过了。

## 标准库类型 string

`string` 表示可变长的字符序列

**C++ 标准一方面对库类型所提供的操作做了详细规定，另一方面也对库的实现者做出一些性能上的需求。因此，标准库类型对于一般应用场合来说有足够的效率。**

### 定义和初始化 `string` 对象

怎么初始化类的对象由类本身决定。一个类可以有定义很多种初始化对象的方式，只不过这些方式之间必须有所区别：要么是初始值的数量不一样，要么是初始值的类型不一样。

```c++
string s1;			// 默认初始化 s1是个空字符串
string s2 = s1;		// s2是s1的副本
string s3 = "hiya";	// s3是该字符串字面值的副本，也可以写作string s3("hiya");
string s4(10, 'c');	// s4的内容是cccccccccc 即10个c
```

#### 直接初始化和拷贝初始化

如果使用 `=` 初始化一个变量，实际上执行的是**拷贝初始化**(copy initialization)，编译器把等号右边的初始值拷贝到新创建的对象中去。如果不适用等号，则执行的是**直接初始化**(direct initialization)。

```c++
string s5 = "hiya";			// 拷贝初始化
string s6("hiya");			// 直接初始化
string s7(10,'c');			// 直接初始化

// 对于多个值进行初始化的情况，非要用拷贝初始化的方式来处理也可以，但是要显示地创建一个临时对象用于拷贝
string s8 = string(10,'c');	// 拷贝初始化 s8 = cccccccccc
// s8等价于 string temp(10,'c'); stromg s8 = temp;
```

### string 对象上的操作

类除了要规定初始化其对象地方式以外，还要定义对象上所能执行的操作。其中，类既能定义通过函数名调用的操作，如 `Sales_item对象.isbn` 那样，也能定义 `<<`、`+` 等各种运算符在该类对象上的新含义

| string 操作           | 解释                                                                                  |
| ----------------------- | --------------------------------------------------------------------------------------- |
| `os<<s`                 | 将 `s` 写到输出流 `os` 中，返回 `os`                                          |
| `is>>s`                 | 将 `is` 中读取字符串赋给 `s`，字符串以空白分隔，返回 `is`          |
| `getline(is, s)`        | 将 `is` 中读取一行赋给 `s`，返回 `is`                                        |
| `s.empty()`             | `s` 为空返回 `true`，否则返回 `false`                                          |
| `s.size()`              | 返回 `s` 中字符的个数                                                           |
| `s[n]`                  | 返回 `s` 中第 `n` 个字符的引用，位置从 0 开始                           |
| `s1+s2`                 | 返回 `s1` 和 `s2` 连接后的结果                                                 |
| `s1=s2`                 | 用 `s2` 的副本代替 `s1` 原来的字符                                           |
| `s1==s2`                | 如果 `s1` 和 `s2` 中所含的字符完全一致，则它们相等：大小写敏感 |
| `s1!=s2`                | 等性判断对字母的大小写敏感                                                 |
| `<`、`<=`、`>`、`>=` | 利用字符在字典中的顺序进行比较，大小写敏感                         |

#### 读写 string 对象

```c++
int main(){
	string s;
	cin >> s;
	cout << s << endl;
    return 0;
}
```

在执行读取操作时，string 对象会自动忽略开头的空白(空格、换行符、制表符等)并从第一个真正的字符开始读起，直到遇到下一处空白。也就是说上示例如果输入 `“    Hello World!   ”`，实际上读入的是 `Hello`。

和内置类型的输入输出操作一样，string 对象的此类操作也是返回运算符左侧的运算对象作为其结果。所以多个输入或者多个输出可以写在一起

```c++
string s1, s2;
cin >> s1 >> s2;			// 输入"hello world!"，s1接收hello s2接收world!
cout << s1 << s2 << endl;
```

#### 读取未知数量的 string 对象

```c++
int main(){
	string word;
	while(cin >> word)
		cout << word << endl;
	return 0;
}
```

#### 使用 getline 读取一整行

有时我们想要输入的字符串保留空白符，就要用`getline`函数代替原来的 `>>` 运算符。`getline` 函数的参数是一个输入流和一个 `string` 对象，函数从给定的输入流中读入内容，直到遇到换行符为止(包括换行符本身)，然后把所读内容存入到 `string` 对象中(不含换行符)。`getline` 只要遇到换行符就结束读取操作并返回，即使一开始就是换行符也会停止。如果一开始就输入换行符那么 `string` 接收的就是个空字符串。

与 `>>` 一样，`getline` 也会返回它的流参数。所以 `getline` 也可以作为条件表达式使用。

```c++
int main(){
	string line;
	// 每次读入一整行，直至文件末尾
	while (getline(cin, line))
		cout << line << endl;
	return 0;
}
```

**触发 `getline` 函数返回的那个换行符实际上被丢弃了，得到的 `string` 对象中并不包含换行符。**

#### string 的 empty 和 size 操作

`empty`是`string`的成员函数，用于判断该`string`对象是否为空。

```c++
while (getline(cin. line))
	if (!line.empty()) cout << line << endl;
```

使用**逻辑非运算符 `!`，返回与运算对象相反的结果。此例中加上 `!` 表示：如果 `line.empty()` 为空则返回假。

`size`函数返回 `string` 对象的长度(也就是 `string` 对象中字符的个数)，可以使用 `size` 函数只输出长度超过 80 个字符的行：

```c++
string line;
// 每次读入一行，只有字符超过80才输出
while (getline(cin, line)) 
    if (line.size() > 80)
        cout << line << endl;
```

#### string::size_type 类型

对于 `size` 函数来说，其实返回的不是 `int` 或者 `unsigned`，而是 `string::size_type` 类型的值。

`string` 类及其他大多数标准库类型都定义了几种配套的类型。这些配套类型体现了标准库类型与机器无关的特性，类型`size_type`就是其中的一种。在具体使用时，需要通过作用域操作符表明 `size_type` 是在 `string` 中定义的。

`size_type` 是一个无符号类型的值，且能存放任何 `string` 对象的大小。

C++11 新增允许编译器通过 `auto` 或者 `decltype` 来推断变量的类型

```c++
auto len = line.size();		// len的类型是string::size_type
```

如果在表达式中混用了带符号数和无符号数有可能会产生意料之外的结果。

```c++
int n = -5;
```

如果 `s.size() < n;`，那么结果可以肯定是 `true`。因为负值会被转换成一个比较大的无符号值。

**如果一条表达式中已经有了 `size` 函数就不要再用 `int` 了，这样可以避免混用 `int` 和 `unsigned` 可能带来的问题。**

#### 比较 string 对象

1. 如果两个 `string` 对象的长度不同，短 `string` 对象的每个字符都跟长 `string` 对象对应的字符相同，那么短 `string` 小于长 `string`
2. 如果两个 `string` 对象在某些对应的位置上不一致，则 `string` 对象比较的结果是 `string` 对象中第一对相异字符比较的结果

```c++
string str = "Hello";
string pharse = "Hello World";
string slang = "Hiya";
```

根据规则一可得：`str < pharse`

根据规则二可得：`slang>pharse>str`

#### 为 string 对象赋值

```c++
string st1(10,'c'),st2;		// st1 = cccccccccc st2 = ""
st1 = st2;					// st1 = "" st2 = ""
```

#### 两个 string 对象相加

```c++
string s1 = "hello, ", s2 = "world\n";
string s3 = s1 + s2;			// s3 = "hello, world\n"
s1 += s2;						// s1 = "hello, world\n"
```

#### 字面值和 string 对象相加

当把 string 对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保每个 `+` 两侧的运算对象至少有一个是 `string`。但其实工作机理和连续输入输出是一样

```cpp
string s1 = "hello", s2 = "world";
string s3 = s1 + ", " + s2 + '\n';	// 正确 string + 字符串字面值 + string + 字符串字面值

string s4 = s1 + ", ";				// 正确 string + 字符串字面值
string s5 = "hello" + ", ";			// 错误 字符串字面值 + 字符串字面值
string s6 = s1 + ", " + "world";	// 正确 相当于 (string + 字符串字面值) + 字符串字面值
string s7 = "hello" + ", " + s2;	// 错误 字符串字面值 + 字符串字面值 + s2
```

`string s6 = s1 + ", " + "world";` 可以理解为如下

```c++
string tmp = s1 + ", ";
s6 = tmp + "world";
```

因为某些历史原因，也为了与 C 兼容，所以 C++ 语言中的字符串字面值不是标准库类型 `string` 的对象。也就是说，字符串字面值和 `string` 是不同的类型。

### 处理 string 对象中的字符

| cctype 头文件中的函数 | 解释                                                                                                     |
| ---------------------------- | ---------------------------------------------------------------------------------------------------------- |
| `isalnum(c)`                 | 当 `c` 是字母或数字时为真                                                                        |
| `isalpha(c)`                 | 当 `c` 是字母时为真                                                                                 |
| `iscntrl(c)`                 | 当 `c` 是控制字符时为真                                                                           |
| `isdigit(c)`                 | 当 `c` 是数字时为真                                                                                 |
| `isgraph(c)`                 | 当 `c` 不是空格但可以打印时为真                                                               |
| `islower(c)`                 | 当 `c` 是小写字母时为真                                                                           |
| `isprint(c)`                 | 当 `c` 是可打印字符时为真(即 `c` 是空格或 `c` 具有可视形式)                           |
| `ispunct(c)`                 | 当 `c` 是标点符号时为真(即 `c` 不是控制字符、数字、字母等)                          |
| `isspace(c)`                 | 当 `c` 是空白时为真(空格、横向制表符、纵向制表符、回车符、换行符、进纸符) |
| `isupeer(c)`                 | 当 `c` 是大写字母时为真                                                                           |
| `isxdigit(c)`                | 当 `c` 是十六进制数字时为真                                                                     |
| `tolower(c)`                 | 如果 `c` 是大写字母，输出对应的小写字母，否则原样输出 `c`                          |
| `toupper(c)`                 | 如果 `c` 是小写字母，输出对应的大写字母，否则原样输出 `c`                          |

#### 建议使用 C++ 版本的 C 标准库头文件。

C++ 标准库中除了定义 C++ 语言特有的功能外，也兼容了 C 语言的标准库。C 语言的头文件形如 `name.h`，C++ 则将这些文件命名为 `cname`。也就是去掉了 `.h` 后缀，而在文件名 `name` 之前添加了 `c`，这里的 `c` 表示这是一个属于 C 语言标准库的头文件。

因此，`cctype` 头文件和 `ctype.h` 头文件的内容是一样的，只不过从命名规范上来讲更符合 C++ 语言的要求。

在 `cname` 的头文件中定义的名字从属于命名空间 std，而定义在名为 `.h` 的头文件就不是。

一般来说，C++ 程序应该使用名为 `cname` 的头文件而不是 `name.h` 的形式，标准库中的名字总能在命名空间 `std` 中找到。如果使用 `.h` 形式的头文件，程序员就不得不时刻记得哪些是从 C 语言中继承过来的，哪些又是 C++ 语言所独有的。

#### 处理每个字符 `?` 使用基于范围的 for 语言

C++11 新增语句**范围 `for`**(range for)语句。这种语句遍历给定序列中的每个元素并对序列中的每个值执行某种操作：

```c++
for (declaration : expression)
	statement
```

其中 `expression` 部分是一个对象，用于表示一个序列。`decllaration` 部分负责定义一个变量，该变量会被用在访问序列中的基础元素。每次迭代，`declaration` 部分的变量会被初始化为 `expression` 部分的下一个元素值。

```c++
string str("some string");
// 每行输出str中的一个字符
for (auto c : str)				// 事实上c是char类型
	cout << c << enldl;			// 输出s\no\nm\ne\n \ns\nt\nr\ni\nn\ng\n\0\n
```

示例使用范围 for 语句和 ispunct 来统计对象中标点符号的个数

```c++
string s("Hello World!!!");
decltype(s.size()) punct_cnt = 0;				// punct_cnt的类型即string::size_type
for (auto c : s) if (ispunct(c)) ++punct_cnt;
cout << s << "中有" << punct_cnt << "个标点符号" << endl;
```

#### 使用范围 for 语句改变字符串中的字符

如果想修改 `string` 对象中字符的值，必须把循环变量定义成引用类型。所谓引用只是给对象的一个别名，所以如果使用引用作为循环控制变量，这个变量实际上被依次绑定到了序列的每个元素。使用该引用，就能改变它绑定的字符。

```c++
int main(){
    string s("Hello World!!!");
    // 转换为大写形式
    for (auto &c : s) c = toupper(c);
    cout << s << endl;			// s = HELLO WORLD!!!
    return 0;
}
```

#### 只处理一部分字符

想访问 string 对象中的单个字符有两种方式：

1. 使用下标
2. 使用迭代器

下标运算符 `[]`接收的输入参数是 `string::size_type` 类型的值，这个参数表示要访问的字符的位置。返回值是该位置上字符的引用。

下标的值又称**索引**，任何表达式只要它的值是一个整型值就能作为索引。但是如果某个索引是带符号类型的值就会自动转换成由 `string::size_type` 表达的无符号类型。

```c++
if(!s.empty()) 
    cout << s[0] << endl;	// 确保有字符可以输出，输出s的第一个字符
```

只要字符串不是常量就能通过下标运算符给其重新赋值。

也能通过下标进行迭代操作

```c++
int main(){
    // 依次处理s中的字符直到处理完全部字符或者遇到一个空白
    for (
        decltype(s.size()) index = 0;
        index != s.size() && !sspace(s[index]);	// 当前下标不跟字符全长相同也不是空
        ++index
        )
        s[index] = toupper(s[index]);   // 将当前字符改成大写
}
```

使用了逻辑与运算符 `&&`。如果参与运算左右两个运算对象都为真，则逻辑与结果为真，否则为假。

下标必须大于等于 0 而小于字符串的 `size()` 的值。一种方法是，将下标的类型设置为 `string::size_type`，因为这个类型就是无符号数，可以确保下标不会小于 0。这时只要保证下标小于 `size()` 的值就行了。

#### 使用下标执行随机访问

也可以通过计算获得某个下标值，然后直接获取对应位置的字符

示例把 0 到 15 之间的十进制数转换成对应的十六进制形式，只需初始化一个字符串令其存放 16 个十六进制“数字”

```c++
int main(){
    const string hexdigits = "0123456789ABCDEF";    // 可能的十六进制数字
    cout << "输入0到15间的数字" << endl;
    string result;          // 保存16进制的字符串
    string::size_type n;    // 保存从输入流读取的数
    cin >> n;
    if (n < hexdigits.size())
        result += hexdigits[n];
    cout << "对应的16进制数为:" << result << endl;
    system("pause");
    return 0;
}
```

### 例题

```c++
string s;
cout << s[0] << endl;
```

上述代码中 `s[0]` 越界了，输出什么都有可能

```c++
const string s = "Keep out !";
for (auto &c : s) { /*...*/ }
```

`c` 是 `s` 每个的字符引用，`s` 是常量，虽然这样是合法的，但是如果想通过 `c` 修改 `s` 中的内容，或是想给 `c` 重新就会报错。

## 标准类型 vector

标准库类型 **vector**(向量)表示对象的集合，其中所有对象的类型都想相同。每一个对象都有一个对应的索引，索引用于访问对象。因为 vector"容纳着"其他对象，所以它也常被称为**容器**(container)。

要想使用 vector，必须包含`vector`头文件。

```c++
#include <vector>
using std::vector;
```

C++ 语言既有**类模板**(class template)，也有函数模板，其中 vector 是一个类模板。

模板本身不是类或者函数，可以将模板看成是编译器生成类或者函数编写的一份说明。编译器根据模板创建类或者函数的过程称之为**实例化**(instantiation)，使用模板的时候，需要指出编译器应该把类或者函数实例化成为哪种类型。

于类模板言，我们通过提供一些额外信息来指定模板到底实例化成什么样的类，需要提供哪些信息由模板决定。

提供信息的方式：

```c++
vector<int> ivec;					// ivec 保存int类型的对象
vector<Sales_item> Sales_vec;		 // 保存Sales_item类型的对象
vector<vector<string>> file;		 // 该向量的元素是vector对象 类似于[[file]] file为string类型
```

上述例子中，编译器根据模板 vector 生成了三种不同的类型：

1. `vector<int>`
2. `vector<Sales_item>`
3. `vector<vector<string>>`

vector 是模板而不是类型，由 vector 生成的类型必须含有 vector 中元素的类型，如 `vector<int>`

vector 能容纳绝大多数的对象作为其元素，但是因为引用不是对象，所以不存在包含引用的 vector。

大多数内置类型和类类型都可以构成 vector 对象，甚至组成 vector 的元素也可以是 vector。

早期版本的 C++ 标准中如果 vector 的元素是 vector(或者其他模板类型)，则它定义的形式与现有的 C++11 新标准略有不同。过去，必须在外层 vector 对象的右尖括号和其元素类型间添加一个空格，如应写成 `vector<vector<int> >`，某些编译器可能仍然需要以老式的声明语句来处理元素为 vector 的 vector 对象。

### 定义和初始化 vector 对象

和任何一种类类型相同，vector 模板控制着定义和初始化vector的方法。

| 方法                    | 含义                                                                         |
| ------------------------- | ------------------------------------------------------------------------------ |
| `vector<T> v1`            | v1 是个空 vector，潜在元素是 T 类型，执行默认初始化         |
| `vector<T> v2(v1)`        | v2 中包含有 v1 所有元素的副本                                       |
| `vector<T> v2 = v1`       | 与 v2(v1)相同，v2 包含 v1 所有元素的副本                          |
| `vector<T> v3(n, val)`    | v3 包含了 n 个重复的元素，每个元素的值都是 val               |
| `vector<T> v4(n)`         | v4 包含了 n 个重复地执行了值初始化对象                         |
| `vector<T> v5{a,b,c...}`  | v5 包含了初始值个数的元素，每个元素被赋予相应的初始值 |
| `vector<T> v5={a,b,c...}` | 与 v5{a,b,c...}相同                                                         |

```c++
// 默认初始化vector对象，从而创建一个指定类型的空vector
vector<string> svec;			// 默认初始化，svec不含任何元素
```

```c++
vector<int> ivec;
// 给ivec添加一些值
vector<int> ivec2(ivec);			// 拷贝ivec给ivec2
vector<int> ivec3 = ivec;			// 拷贝ivec给ivec3
vector<string> svec(ivec2);			// 错误 类型需要是int
```

#### 列表初始化 vector 对象

C++11 新标准提供的方法。

```cpp
vector<string> articles = {"a", "an", "the"};
```

在大多时候这些初始化方式可以相互等价使用，但并非一直可以。

1. 使用拷贝初始化时候(=)，只能提供一个初始值
2. 若提供的是一个类内初始值，则只能使用拷贝初始化或者花括号的形式初始化。
3. 如果提供的是初始化元素值的列表，则只能把初始值都放在花括号里进行列表初始化。而不能放在圆括号里。

```c++
vector<string> v1{"a", "an", "the"};		// 列表初始化
vector<string> v2("a", "an", "the");		// 错误
```

#### 创建指定数量的元素

```c++
vector<int> ivec(10, -1);			// 10个int类型的元素，每个都被初始化为-1
vector<string> svec(10, "hi!");		// 10个string类型的元素，每个都被初始化为"hi!"
```

#### 值初始化

可以只提供 vector 对象容纳的元素数量而略去初始值。此时库会创建一个**值初始化的**(value-initialized)元素初值，并把它赋给容器中的所有元素。该初值由 vector 对象中的元素类型决定。

如：

1. `vector<int>` 则是 0
2. `vector<string>`，string 非内置类型，所以由 string 类决定。string 类决定它们是空字 string 对象

这种初始化方式有两个特殊限制：

1. 有些类要求必须明确地提供初始值，如果 vector 对象中元素的类型不支持默认初始化，我们就必须提供初始的元素值。
2. 如果只提供了元素的数量而没有设定初始值，只能使用直接初始化

   ```c++
   vector<int> vi = 10;		// 错误 必须使用直接初始化的形式指定vector的大小
   vector<int> vi(10);			// 直接初始化 正确
   ```

#### 列表初始化还是元素数量？

```c++
vector<int> v1(10);			// v1有10个元素 每个值都是0
vector<int> v2{10};			// v2有1个元素 元素值为10

vector<int> v3(10, 1);		// v3有10个元素 初始值都是1
vector<int> v4{10, 1};		// v4有2个元素 为10和2
```

若是圆括号，可以说提供的值是用来构造(construct)vector 对象的。

如 v1 的初始值说明了 vector 对象的容量，v3 的两个初始值则分别说明了 vector 对象的容量和元素的初值。

如果是花括号，可以表述成我们想**列表初始化**(list initialize)该 vector 对象。也就是说，初始化过程会尽可能地把花括号内地值当成是元素初始值的列表来处理，只有在无法执行列表初始化时才会考虑其他初始化方式。

如果初始化时候使用了花括号地形式但是提供的值又不可以用来列表初始化，就要考虑用这样的值来构造 vector 对象了。

如，要想列表初始化一个含有 string 对象的 vector 对象，应该提供能赋给 string 对象的初值。

```c++
vector<string> v5{"hi"};		// 正确 列表初始化
vector<string> v6("hi");		// 错误 构造
vector<string> v7{10};			// 正确 v7有10个默认初始化的元素 不是列表初始化
vector<string> v8{10, "hi"};	//  正确 v8 有10个为"hi"的元素 不是列表初始化
```

上述例子只有 `v5` 是列表初始化。要想列表初始化 vector 对象，花括号里的值必须与元素类型相同。

确认无法执行列表初始化后，编译器会尝试使用默认值初始化 vector 对象。

### 向 vector 对象添加元素

对 vector 对象来说，直接初始化的方式适用于三种情况

1. 初始值已知且数量较少
2. 初始值是另一个 vector 对象的副本
3. 所有元素的初始值都一样

但我们更多还是需要向 vector 添加元素

先创建一个 vector，然后在运行时再利用 vector 的成员函数 **push_back** 向其中添加元素。push_back 负责把一个值当成 vector 对象的尾元素添加到 vector 对象的尾端。

```c++
vector<int> v2;
for (int i = 0; i != 100; ++i)
    v2.push_back(i);		// 以此把i添加到v2尾端
// 循环结束后v2有100个元素，值从0到99
```

也可以实时读入数据然后添加到 vector 对象

```c++
string word;
vector<string> text;		// 空vector对象
while (cin >> word){
	text.push_back(word);	// 将输入的word添加到text尾端
}
```

#### **关键：vector 对象能高效增长**

**C++ 标准要求 vector 应该能在运行时候高效地添加元素。因此既然 vector 对象能高效地增长，那么在定义 vector 对象的时候设定其大小也就没什么必要了，事实上还可能导致性能降低。只有一种例外情况，就是所有元素地值都相同。如果有个元素的值不一样，就应该定义个空 vector 对象，再在运行时候向里面添加具体值。**

#### 向 vector 对象添加元素蕴含的编程假定

因为可以高效地向 vector 对象中添加元素，很多编程工作被极大简化了。但是这种简便性也伴随一些对编程更高的要求：

- 必须要确保所写的循环正确无误，特别是在循环有可能改变 vector 对象容量的时候。

如果循环体里面有向 vector 对象添加元素的语句，就不能适用范围 for 循环。

**范围 for 语句里面不应该改变其所遍历序列的大小。**

#### 其它 vector 操作

除 push_back 以外的几种操作。大多与 string 相关操作类似

| 操作            | 含义                                                 |
| ----------------- | ------------------------------------------------------ |
| `v.empty()`       | 判断`v`是否为空 |
| `v.size()`        | 返回`v`元素个数<br />返回类型是vector定义的`size_type`类型`vector<该容器类型>::size_type` |
| `v.push_back(t)`  | 给`v`尾端添加`t`元素           |
| `v[n]`            | 返回`v`中第`n`个位置上元素的引用      |
| `v1 = v2`         | `v2`的所有元素拷贝给`v1`                      |
| `v1 = {a,v,c...}` | 用花括号中的元素替换`v1`中的元素       |
| `v1 == v2` 、 `v1 != v2` | 判断两个容器元素是否相等                          |
| `<,<=,>,>=`       | 字典顺序进行比较                               |

```c++
vector<int> v{1,2,3,4,5,6,7,8,9}
for(auto &i : v)		// 对于v中的每个元素(i是一个引用)
	i*=i;			    // i = i * i(平方)
for (auto i : v)		// 使用i遍历v中的每个值
	cout << i << " ";	// 输出i的值
cout << endl;			// 结束，刷新缓冲区
```

各个相等性运算符和关系运算符也与 string 的相应运算符功能相同。

如果两个 vector 对象的容量不同：

- 相同位置上的元素值相同，则元素少的 vector 对象小于长的；
- 若元素的值有区别，则由第一对不同的元素值的大小关系决定。

只有元素的值可以比较时候，vector 对象才能被比较。例如 int 和 string 可以，但是有时候如 Sales_item 就不能。像 `vector<Sales_item>` 这样就不能比较，而只能存值

#### 计算 vector 里对象的索引

使用下标运算符可以获取对应位置的元素。下标类型是相应的`size_type`类型。只要 vector 对象不是一个常量，就能向下标运算符返回的元素赋值。

示例成绩集合，其中成绩取值为 0 至 100。以 10 分为一个分数段，要求统计各个分数段各有多少个成绩。算上 0 本身，即 0-9、10-19、20-29、30-39、40-49、50-59、60-69...共有 11 个分数段，最后一个分数段(100)统计满分 100 的数量。

按示例所说，我们输入

```
42 65 95 100 39 69 95 76 83 82 76 93
```

应该返回

```
0 0 0 1 1 0 2 3 2 4 1
```

在具体实现时候使用一个含有 11 个元素的 vector 对象，每个元素分别用于统计各个分数段上出现的成绩个数。对于某个成绩来说，将其除以 10 就能够得到对应的分数段索引。两个数相除，结果还是整数，余数部分被自动忽略了。如 42/10=4、65/10=6。得到了分数段索引，就可以用它作为 vector 对象的下标，进而获取该分数段的计算值并加 1。

```c++
// 以10分为一个分数段统计成绩的数量
vector<unsigned> scores(11, 0);		// 11个分数段，全部初始化为0
unsigned grade;
while(cin >> grade){
	if (grade <= 100)			   // 仅处理有效输入
		++scores[grade/10]		   // vector对应索引自增1
}
```

#### 不能用下标形式添加元素

```c++
vector<int> ivec;		// 空vector对象
for (decltype(ivec.size()) ix = 0; ix != 10; ++ix)
	ivec[ix] = ix;			// 严重错误！ivec不包含任何元素
```

如果想要如上所示添加，我们应该使用 push_back 添加到末尾

```c++
vector<int> ivec;
for (decltype(ivec.size()) ix = 0; ix != 10; ++ix)
	ivec.push_back(ix);		// 正确！添加一个新元素到ivec末尾，元素值为ix
```

**vector 对象的下标运算符可以用于访问已经存在的元素，但不能用于添加元素**

也就是只能对已经存在的的元素执行下标操作。

```c++
vector<int> ivec;	// 空vector对象
cout<< ivec[0];		//  错误 ivec不包含任何元素
```

确保下标合法的一种有效手段就是尽量使用范围 for 语句。

#### 练习

```c++
vector<int> v1;			// 空 无元素
vector<int> v2(10);		// 10个元素 都是0
vector<int> v3(10, 42);	// 10个元素 都是42
vector<int> v4{10};		// 1个元素 42
vector<int> v5{10, 42};	// 2个元素 10和42
vector<string> v6{10};	// 10个空string对象
vector<string> v7{10, "hi"};		// 10个"hi"
```

## 迭代器介绍

string 也支持迭代器。

除了下标运算符`[n]`，还可以使用**迭代器**(iterator)来访问string或vector对象

类似于指针类型，迭代器也提供了对对象的间接访问。

就迭代器而言，其对象是容器中的元素或者 string 对象中的字符。

使用迭代器可以访问某个元素，迭代器也可以从一个元素移动到另一个元素。

迭代器有有效与无效区别：

- 有效的迭代器指向某个元素，或者指向容器中尾的下一个位置
- 其它的情况都属于无效的迭代器。

### 使用迭代器

有迭代器的类型同时拥有返回迭代器的成员。

例如，这些类型都含有名为 **begin** 和 **end** 的成员，其中 begin 成员负责返回指向第一个元素(或者一个字符)的迭代器。

```c++
// 由编译器决定b和e的类型
// b表示v的第一个元素 e表示v尾元素的下一个位置
auto b = v.begin(), e = v.end();		// b和e的类型相同
```

end 成员返回指向容器(或者 string 对象)尾元素的**下一个位置**(one past the end)的迭代器，也就是说，该迭代器指的是容器一个本不存在的**尾后**(off the end)元素。这样的迭代器表示我们已经处理完成容器中的所有元素。

`end`成员返回的迭代器常称**尾后迭代器**(off-the-end iterator)或者**尾迭代器**(end iterator)。

若容器为空，那么`begin`和`end`返回同一个迭代器，都是尾迭代器。

#### 迭代器运算符

| 运算符使用  | 含义                                                                                                                                                          |
| ---------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `*iter`          | 返回迭代器 iter 所指元素的引用                                                                                                                      |
| `iter->mem`      | 解引用 iter 并获取该元素的名为 mem 的成员，等价于(*iter).mem                                                                                 |
| `++iter`         | 令 iter 指示容器的下一个元素                                                                                                                         |
| `--iter`         | 令 iter 指示容器的上一个元素                                                                                                                         |
| `iter1 == iter2` | 判断两个迭代器是否相等，若两个迭代器指示的是同<br />一个元素或者是同一个容器的尾后迭代器就相等，否则就不相等 |
| `iter1 != iter2` | 对上一个含义的结果取反                                                                                                                               |

示例使用迭代器将一个 string 对象所有内容转成大写

```c++
string s("some string");
if (s.begin() != s.end()){		// 确定当前迭代器非尾迭代器(非空)
	auto it = s.begin();		// it指向s的第一个字符
	*it = toupper(*it);			// 解引用符it并且重新赋值
}
// 返回: Some string
```

#### 将迭代器从一个元素移动到另外一个元素

迭代器使用递增(++)运算符来从一个元素移动到下一个元素。

逻辑上说，迭代器的递增和整数的递增欸四，整数的递增是在整数值上"加 1"，迭代器的递增是把迭代器"向前移动一格位置"。

因为 end 返回的迭代器并不实际指向某个元素，所以不能对其进行递增或者解引用的操作。

使用迭代器将一个单词转换为大写

```c++
// 以此处理s的字符直至我们处理完全部字符或者遇到空白
for (auto it = s.begin(); it != s.end() && !isspace(*it); ++it)
	*it = toupper(*it);			// 解引用it 将当前字符改成大写形式
// 若s是some 那么就转换成了 SOME
// 若s是some string 那么就转换成了 SOME string
```

**泛型编程**

**大多从 C 或者 JAVA 转来 C++ 的人可能会使用 < 而非!=。所有标准库容器的迭代器都定义了==和!=，但它们的大多数都没有定义 < 运算符。**

#### 迭代器类型

那些拥有迭代器的标准库类型使用 iterator 和 const_iteraor 来表示迭代器的类型

```c++
vector<int>::iterator it;			// it能读写vector<int>的元素
string::iterator it2;				// i2能读写string对象中的字符

vector<int>::const_iterator it3;	// it3只能读元素 不能写元素
string::const_iterator it4;			// it4只能读字符 不能写字符
```

const_iterator 和常量指针类似。若 vector 对象或 string 对象是一个常量，只能使用 const_iterator；若 vector 对象或 string 对象不是常量，那么两种都能用。

**迭代器和迭代器类型**

1. 迭代器概念本身
2. 容器定义的迭代器类型
3. 某个迭代器对象

重点是理解存在于一组概念上相关的类型，我们认定某个类型是迭代器且它支持一套操作，这套操作使得我们能够访问容器的元素或者从某个元素移动到另外一个元素。

每个容器类定义了一个名为 iterator 的类型，该类型支持迭代器概念所规定的一套操作。

#### begin 和 end 运算符

如果对象是常量，那么 begin 和 end 返回 const_iterator，如果对象非常量，就返回 iterator

若只使用读操作那最好就用常量类型(const_iterator)。为了便于得到 const_iterator，C++11 新标准引入 cbegin、cend

```c++
auto it3 = v.cbegin();		// it3的类型是const_iterator
```

cbegin 与 cend 作用类似 begin 和 end，不过它们返回的固定是 const_iterator，不可修改。

#### 结合解引用和成员访问操作

```c++
vector<string> v{"a", "b"};
auto it = v.cbegin();

(*it).empty();           // 判断*it是否为空 也就是通过迭代器判断v是否为空容器
*it.empty();			 // 错误 试图访问it的名为empty的成员 但it是个迭代器 没有empty成员
```

`(*it).empty()` 是先对 `*it` 解引用，然后解引用的结果再执行点运算符。若不加圆括号，点运算符将由 `it` 而不是 `*it` 来执行。

为了简化如上步骤，C++ 语言定义了**箭头运算符** `->`。

箭头运算符把解引用和成员访问两个操作结合在一起，也就是说，`it->mem` 与 `(*it).mem`相同。

```c++
// 依次输出text的每一行直到遇到第一个空白行为止
for (auto it = text.cbegin(); it != text.cend() && it->empty(); ++it)
	cout << *it << endl;
```

`it->empty()` 将`it`的值取出然后使用`empty()`函数判断是否为空

使用箭头运算符将一个单词转为大写。

```c++
string s = "hello world!";
for (auto it = text.begin(); it != text.cend() && it->empty(); ++it))
	*it = toupper->it;
cout << s << endl;
```

#### 某些对 vector 对象的操作会使迭代器失效

虽然 vector 可以动态增长，但也有副作用。

- 一个限制是不能在范围 for 循环中向 vector 对象添加元素。
- 另外一个限制是任何一种可能改变 vector 对象容量的操作，如 push_back 都会使得该 vector 对象的迭代器失效。

也就是说只要使用了迭代器的循环体，就不要向迭代器所属的容器添加元素。

#### 练习

将 text 中的所有元素转换为大写

```c++

int main(){
    vector<string> text = {"apple","banana","peach"};
    for (auto it = text.begin(); it != text.end() && !it->empty(); ++it){
        for(auto &i:*it)
            i = toupper(i);
        cout << *it << endl;
    }

    return 0;
}
```

将一个含有 10 个整数的 vector 对象中的所有元素转为各自两倍后的值。

```c++
int main(){
    vector<int> numbers{1,2,3};
    for (auto &i : numbers){
        i*=2;
    }
    for (auto i : numbers){
        cout << i << endl;
    }
    return 0;
}
```

### 迭代器运算

| vector 和 string 迭代器支持的操作 | 介绍                                                                                                                                                                                                                                                                         |
| ------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `iter + n`                                 | 迭代器向前移动`n`个位置                   |
| `iter - n`                                 | 与 `+` 相反，不过如果还是超了那还是指是尾元素的下一个位置                                                                                                                                                                                            |
| `iter1 += n`                               | 将 `iter1`+`n` 的结果赋给 `iter1`                                                                                                                                                                                                                                        |
| `iter1 -= n`                               | 将 `iter1`-`n` 的结果赋给 `iter1`                                                                                                                                                                                                                                        |
| `iter1 - iter2`                            | 两个迭代器相减结果是它们之间的距离。也就是将运算符右侧的迭代器向前移动差值个元素后就得到左边的迭代器。<br />参与运算的两个迭代器必须指向的是同一个容器中的元素或者尾元素的下一个位置。 |
| `>、>=、<、<=`                          | 若某迭代器指向的容器位置在另一个迭代器所指向位置前，则前者小于后者。<br />参与运算的两个迭代器必须指向同一个容器中的元素或者尾元素的下一位置。                                                             |

这些运算符称为**迭代器运算**(iterator arithmetic)，可以使得迭代器每次移动跳过多个元素，也支持迭代器进行关系运算。

#### 迭代器的算术运算

```c++
// 计算得到最接近vi中间元素的一个迭代器
auto mid = vi.begin() + vi.size() / 2;
```

若 vi 有 20 个元素，那么 `vi.size()/2`​ 得到 10，此例中即是 mid 等于 `vi.begin()+10`。

已知下标从 0 开始，则迭代器所指的元素是 vi[10]，也就是首元素开始向前相隔 10 个位置的那个元素。

于 string 或 vector 的迭代器而言，除了判断是否相等，还能使用关系运算符对其进行比较。参与比较的两个迭代器必须合法且指向同一个容器元素(或尾元素的下一位置)。如 `it` 和 `mid` 是同一个容器对象，那么可以使用 `if(it < mid)` 来比较它们所指的位置先后。

所谓两个迭代器的距离指的是右侧迭代器向前移动多少位置就能追上左侧的迭代器，其类型是名为 `defference_type` 的带符号整数。string 和 vector 都定义了 `defference_type`。

#### 使用迭代器运算

一个经典算法是二分搜索。二分搜索从有序序列中寻找某个给定的值。二分搜索从序列中间的位置开始搜索，如果中间位置的元素正好就是要找的元素，搜索完成；若不是，则该元素小于要找的元素，就在序列的后半部分继续搜索；若元素大于要找的元素，则在序列的前半部分继续搜索。在缩小的范围中计算一个新的中间元素并重复之前的过程，直到最终找到目标或者没有元素可以找。

```c++
// 使用迭代器完成二分搜索示例
// 假设我们有一个sought的数要在text序列中找
// text必须是有序的
// beg 和 end表示我们要搜索的范围
auto beg = text.begin(), end = text.end()
auto mid = text.begin() + (end - beg)/2;		// 初始状态下的中间点
// 当还有元素没有检查并且我们还没有找到sought时执行循环
while (mid != end && *mid != sought){
	if (sought < *mid)				// 如果我们要找的数小于中间数
		end = mid;					// 将查找的结束范围缩小到end
	else
		beg = mid + 1;				// 将开始提前 下次在mid后找
	mid = beg + (end - beg)/2;		// 新的中间点 = 新的开始点 + 末尾到新开始点的距离的一半
}
```

为什么是 `mid = beg + (end - beg)/2` 而不是 `mid = (beg + end)/2`？

因为 `end-beg` 表示的是新的结束点到新的开始点间的距离，也就是下次要查找的长度的距离，将其除以二就表示要从中间开始找，也就是总长度的一半，之后再加上 `beg` 开始点的位置。若使用 `beg+end` 虽然运算快了，但是可能会导致溢出，且两个迭代器相加若没有之后的 `/2` 我们不知道会将迭代器移动到哪里去，我们应该避免这种写法。

## 数组

数组是种类似于标准库类型 vector 的数据结构，但是在性能和灵活性的权衡上又跟 vector 有些不一样。与 vector 相似的地方是，数组也是存放在类型相同的对象的容器。这些对象本身没有名字，需要通过其所在位置访问。与 vector 不同的地方是，数组的大小固定。对于某些特殊的应用来说程序的运行时性能较好，但也损失了一些灵活性。

如果不清楚元素的确切个数，应该使用 vector。

### 定义和初始化内置数组

`a[d]`，其中 a 是数组的名字，d 是数组的维度。维度说明了数组中元素的个数，因此必须大于 0。数组中元素的个数也属于数组类型的一部分，编译的时候维度应该是已知的。也就是说，维度必须是一个常量表达式。

```c++
 unsigned cnt = 42;				// 非常量表达式
 constexpr unsigned sz = 42;	// 常量表达式
 int arr[10];					// 含有10个int类型的数的数组
 int *parr[sz];					// 含有42个int类型的指针的数组
 string bad[cnt];				// 错误 cnt非常量表达式
 string strs[get_size()];		// 如果get_size()是constexpr时正确 否则错误
```

与内置类型的变量相同，若函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值。

定义数组时必须明确定义数组的类型，不能使用 auto 关键字由初始值的列表推断类型。数组的元素应该是对象，不存在引用的数组。

#### 显示初始化数组元素

可以对数组的元素进行列表初始化，此时允许忽略数组的维度。若声明时没有指明维度，编译器会根据初始值的数量计算并推测出来；相反，如果指明了维度，那么初始值的总数量就不该超出指定的大小。

```c++
const unsigned sz = 3;
int ia1[sz] = {0, 1, 2};		// 含有3个元素的数组
int a2[] = {0, 1, 2};			// 含有3个元素的数组
int a3[5] = {0, 1, 3};			// 含有5个元素的数组 前3个是0,1,2 后两个由int初始化为0,0
string a4[3] = {"hi", "bye"};	// 含有3个元素的数组 前两个是"hi","bye" 最后一个是""
int a5[2] = {0,1,2};			// 错误 初始值超出指定维度
```

#### 字符数组的特殊性

字符数组有一种额外的初始化形式，我们可以用字符串字面值对此类数组初始化。包括字符串字面值的末尾那个空字符 `\0` 也会被添加进去。

```c++
char a1[] = {'C', '+', '+'};		// 列表初始化 无空字符
char a2[] = {'C', '+', '+', '\0'};	// 列表初始化 含有显示的空字符
char a3[] = "C++";					// 列表初始化 含有隐式的空字符\0
const char a4[6] = "Daniel";		// 错误 虽然字符串字面值看着只有6个字符 但是实际上还有个\0没有显示出来
```

#### 不允许拷贝和赋值

不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值。

```c++
int a[] = {0, 1, 2};
int a2[] = a;			// 错误 不允许使用一个数组初始化另一个数组
a2 = a;					// 错误 不能把一个数组直接赋值给另一个数组
```

一些编译器允许数组赋值，即**编译器扩展**(compiler extension)。但一般来说，不应该使用非标准特性。

#### 理解复杂的数组声明

默认情况下，类型修饰符从右向左依次绑定。

```c++
int *ptrs[10];		// 定义一个大小为10的数组 名字是ptrs 数组存放的是指向int类型的指针
					// 十个指向int的指针的数组
```

但是有时候我们也需要从内往外理解

```c++
int (*Parray)[10] = &arr;		//  指向一个含有10个整数的数组的指针
```

`(*Parray)` 表示 `Parray` 是个指针，接下来看右边可以得知 `Parray` 是个指向大小为 `10` 的数组的指针，最后再看左边，得知数组中的元素是 `int`。即 `Parray` 是个指针，指向一个 `int` 数组，数组中含有 `10` 个元素。

```c++
int &refs[10] = ...				// 错误 不存在引用的数组
int (&arrRef)[10] = arr			// 正确 arrRef引用一个含有10个整数的数组
int *(&arry)[10] = ptrs			// 正确 arry是数组的引用 该数组中含有10个指针
```

先知 arry 是个引用，然后看右边可知 arry 引用的对象是个大小为 10 的数组，然后再看左边可知，数组的元素类型是指向 int 类型的指针。即(arry 是个含有(10 个(int 型指针)的数组)的引用)。

#### 练习

假设 text_size 是个无参数的函数，返回值是 int。请回答下列哪个定义是非法的？为什么？

```c++
unsigned buf_size = 1024;
int ia[buf_size];		// 非法 buf_size非常量表达式
int ia[4*7-14];			// 合法 4*7-14都是固定的值
int ia[text_size()];	// 不合法 text_size无法判断是否是常量表达式
char st[11] = "fundamental";	// 不合法 初始值大于维度长度
```

下列数组中的元素的值是什么?

```c++
string sa[10];			// 由类初始化 10个空字符串
int ia[10];				// 在全局变量中定义 所以由类初始化 编译器规定
int main(){
	string sa2[10];		// 由类初始化 10个空字符串
	int ia2[10];		// 在局部中定义 局部量不做自动初始化 值不确定 编译器规定
}
```

### 访问数组元素

与标准库类型 vector 和 string 一样，数组的元素也能使用范围 for 语句或下标运算符来访问。数组的索引从 0 开始。

在使用数组下标时，通常将其定义为 **size_t** 类型。size_t 是一种机器相关的无符号类型，它被设计得足够大以便能表示内存中任意对象的大小。在 cstddef 头文件中定义了 size_t 类型，这个文件是 C 标准库 stddef.h 头文件的 C++ 版本。

数组除了大小固定这特点外，其它用法与 vector 基本类似。例如，可以用数组来记录各分数段的成绩个数。

```c++
unsigned scores[11] = {};		// 11个分数段 全部初始化为0
unsigned grade;
while (cin >> grade){
	if (grade <= 100)
		++scores[grade/10];		// 将当前分数段的计数值加1
}
```

本例所用下标是 C++ 直接定义的，而 vector 的下标是由库模板 vector 定义的。

与 vector 一样，如果不想超出数组的范围，最好是用范围 for 循环。

#### 检查下标的值

与 vector 和 string 一样，数组的下表是否在合理范围之内由程序员负责检查，所谓合理就是说下标应该大于等于 0 且小于数组的大小。要想防止数组下标越界，除了注意细节以及对代码彻底的测试之外，没有其它好办法。于程序而言，即使能顺利编译过去，也不能肯定它不包含这些问题。

#### 练习

编写一个程序，定义个含有 10 个 int 的数组，让每个元素的值就是其下标的值

```c++
int main(){
    constexpr size_t array_size = 10;
    int ia[array_size];
    for (size_t ix = 0;ix != 10;ix++)
        ia[ix] = ix;
    for (size_t x : ia)
        cout<< x << endl;
}
```

将上述练习拷贝给另一个数组。利用 vector 重写程序，实现类似功能

```c++
// 拷贝给另一个数组
int ib[array_size];
for (size_t ix = 0;ix != array_size;ix++)
    ib[ix] = ia[ix];


// vector实现
vector<int> ic;

for(int i = 0; i!=10;++i)
    ic.push_back(i);
for(auto x : ic)
    cout << x;
```

于如下程序而言，若是 `scores` 不初始化会如何

```c++

int main(){
    unsigned scores[11] = {};
    unsigned grade;
    while (cin >> grade){
        if (grade <= 100)
            ++scores[grade/10];
            cout << scores[grade/10];
    }
}

```

若 scores 不初始化，那么在对其操作时候可能就会去操作到一个未知的内存地址，使之引发难以预料的后果。

### 指针和数组

在 C++ 中，使用数组时候编译器一般会将其转换为指针。

通常使用取地址符来获取指向某个对象的指针，取地址符可以用于任何对象。数组的元素也是对象，对数组使用下标运算符得到该数组指定位置的元素。

对数组的元素也可以使用取地址符，然后就能得到指向该元素的指针。

```c++
string nums[] = {"one", "two", "three"};
string *p = &nums[0];		// 取的"one"的指针
```

在大多表达式中，使用数组类型的对象其实是使用一个指向该数组首元素的指针。

在一些情况下对数组的操作实际上是指针的操作。当使用数组作为一个 auto 变量的初始值时，推断得出的类型是指针而不是数组。

```c++
int ia[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
auto ia2(ia);		// ia2是一个整数指针 指向ia的第一个元素
ia2 = 42;			// 错误 ia2是个指针 不能用int值给指针赋值
```

编译器实际对 `ia2` 执行的是 `auto ia2(&ia[0]);`，所以 ia2 的类型显然是 `int*`

当使用 decltype 关键字时候上述转换不会发生，decltype(ia)返回的类型是由 10 个整数构成的数组

```c++
// ia3 是一个含有10个整数的数组
decltype(ia) ia3 = {0,1,2,3,4,5,6,7,8,9};
ia3 = p;		// 错误 ia3是int类型的数组 p是string指针
ia3[4] = 5;		// 正确 将5赋给ia3第[4]个元素
```

#### 指针也是迭代器

vector 和 string 的迭代器数组都支持。

```c++
int arr[] = {0,1,2,3,4,5,6,7,8,9};
int *p = arr;		// p指向&arr[0]
++p;				// arr[0+1] *p = arr[1]
```

获取数组的尾元素后那个不存在的元素的地址

```c++
int *e = &arr[10];	// 指向arr尾元素的下一位置的指针
```

不能对尾后指针执行解引用或者递增等操作。

利用尾后指针打印 arr 的全部元素

```c++
int *e = &arr[10];
for (int *b = arr;b!=e;++b)
	cout << *b << endl;
```

#### 标准库函数 begin 和 end

尽管能计算得到尾后指针，但这种用法容易出错。为了使指针的使用更见点，C++11 新增名为 begin 和 end 函数。但数组不是类类型，因此这两个函数不是成员函数。正确的使用方式是把数组作为它们的参数

```c++
int ia[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
int *beg = begin(ia);			// 指向ia首元素的指针
int *last = end(ia);			// 指向ia尾元素的下一个位置的指针
```

这两个函数定义在 iterator 头文件中

使用 begin 和 end 可以简单地写出一个循环并处理数组中的元素。

```c++
// 假设arr是个整型数组 找出arr中的第一个负数
// pbeg指向arr地首元素 pend指向arr尾元素的下一位置
int *pbeg = begin(arr), *pend = end(arr);
// 寻找第一个负值元素 如果已经检查完全部元素则结束循环
while(pbeg != pend && *pbeg >= 0)
	++pbeg;
```

#### 指针运算

指向数组元素的指针加或者减会移动指向数组中元素的位置

```c++
constexpr size_t sz = 5;
int arr[sz] = {1,2,3,4,5};
int *ip = arr;			// = *ip = &arr[0]
int *ip2 = ip+4;		// = *ip2 = &arr[0+4] = &arr[4]
```

指向同一数组的尾元素的下一位置

```c++
int *p = arr + sz;		// arr转换成指向arr首元素的指针 sz即是5 所以p指针指向&arr[5]，但是arr只有[4] 所以是arr数组的尾元素的下一位置
int *p2= arr + 10;		// 下标越界
```

与迭代器相同，两个指针相减的结果是它们之间的距离。参与运算的两个指针必须指向同一个数组当中的元素

```c++
auto n = end(arr) - begin(arr);		// n的值是5 end(5) - begin(0) = 5
```

两指针相减的结果的类型是一种名为**ptrdiff_t**的标准库类型，和size_t一样，ptrdiff_t也是一种定义在cstddef头文件中的机器相关的类型。因此差值可能是负值，所以ptrdiff_t是一种带符号类型。

遍历数组中的元素

```c++
 int *b = arr, *e = arr + sz;
 while(b < e){
 	// 使用 *b
 	++b;
 }
```

若两个指针分别二指向不相关的对象，则不能比较它们

```c++
int i = 0, sz = 42;
int *p =&i, *e= &sz;
// 未定义的p和e没有关系，所以不能比较它们
whlie(p < e)		// 即使可以比较 结果对于数组来说也毫无意义
```

#### 解引用和指针运算的交互

指针加上一个整数的结果还是一个指针。假设结果指针指向了一个元素，则允许解引用该结果指针

```c++
int ia[]= {0,2,4,6,8};		// ia[5]
int last = *(ia+4);			// last = *ia[4] --> last = 8
```

如果表达式含有解引用符和点运算符，最好在必要的地方加上圆括号。

```c++
last = *ia + 4;		// 正确 last = *ia[0] + 4 --> last = 0+4=4
```

含义就和之前的不同了，此时先解引用再给结果加4

#### 下标和指针

```c++
int ia[] = {0,2,4,6,8};		// 含有5个整数的数组

int i = ia[2];				// i = 4
int *p = ia;				// *p --> ia[0] --> 0  *p-->ia
i = *(p + 2);				// ia[0+2] --> ia[2] --> 4 --> i = 4
```

只要指针指向的是数组中的元素(或者数组中尾元素的下一位置)，都可以执行下标运算

```c++
int *p = &ia[2];		// p指向索引为2的元素 --> &(ia[2]) --> &4 --> *p --> &4
int j = p[1];			// p[1]等价于*(p+1)，就是ia[3] --> 6 --> p[1]== *p = &ia[2+1] --> &6 --> j
int k = p[-2];			// *p= &ia[2-2] --> *p = 0 --> k = 0
```

可以理解为数组在内存中是一个一个方块排列，然后我们指针去访问数组的值时，就相当于访问内存当中的值。下标即是数组在内存当中排列的顺序。

标准库类型string和vector也能执行下标运算，但是标准库类型限定使用的下标必须是无符号类型，而内置的下标运算没有做这个限制。内置的下标运算符可以处理负值，但是结果地址必须指向原来的指针所指同一数组中的元素。

内置的下标运算符使用的索引值不是无符号类型，这一点与vector和string不同。

#### 练习

假定p1和p2指向同一个数组的元素，则下面程序的功能是什么？什么情况下该程序是非法的？

```c++
 p1 += p2 - p1
 /*
 p1 = p1 + (p2 - p1)
 p1是常量时候非法
 */
```

编写一段程序，利用指针将数组中的元素置为0

```c++
int main(){
    int ia[] = {0,2,4,6,8};     // 含有5个整数的数组

    int *i = ia;
    int *e = std::end(ia);
    while(i < e){
        *i = 0;
        ++i;
    }
    for (int i : ia)
        cout << i;

    return 0;
}
```

### C语言风格字符串

虽然C++支持C风格字符串，但在C++程序中最好还是不要使用它们。不仅使用不方便，且容易引发程序漏洞。

字符串字面值是一种通用结构的示例，这种结构是C++由C继承而来的**C风格字符串**(C-style character string)。C风格字符串不是一种类型，而是为了表达和使用字符串而形成的一种约定俗成的写法。按此习惯书写的字符串存放在字符数组中并以**空字符结束**(null terminated)。以空字符结束的意思是在字符串最后一个字符后面跟着一个空字符`\0`。一般利用指针来操作这些字符串。

#### C标准String函数

| 函数             | 含义                                                         |
| ---------------- | ------------------------------------------------------------ |
| `strlen(p)`      | 返回p的长度，空字符不计算在内                                |
| `strcmp(p1, p2)` | 比较p1和p2的相等性。两值相等返回0，左大右小为正值，左小右大为负值 |
| `strcat(p1, p2)` | 将p2附加到p1之后，返回p1                                     |
| `strcpy(p1, p2)` | 将p2拷贝给p1，返回p1                                         |

这些函数定义在cstring头文件中，cstring是C语言头文件string.h的C++版本。这些函数不会验证字符参数。

传入此类函数的指针必须要指向以空字符作为结尾的数组

```c++
char ca[] = {'C', '+', '+'};			// 不以空字符结束
cout << strlen(ca) << endl;				// 错误 ca没有以空字符结束
```

#### 比较字符串

比较两个C风格字符串的方法和之前学习过的比较标准库string对象的方法类似。

```c++
string s1 = "A string example";
string s2 = "A different string";
if (s1 < s2)		// 返回 false s2小于s1

// C风格字符串
// 实际比较的是指针而不是字符串本身
const char ca1[] = "A string example";
const char ca2[] = "A different string";
if (ca1 < ca2)		// 未定义的 试图比较两个无关地址
// 实际比较的是两个const char*的值 指针指的不是同一个(数组)对象 所以得到未定义的结果
```

要想比较两个C风格字符串需要调用strcmp函数，此时比较的就不再是指针了。

```c++
if (strcmp(ca1, ca2) < 0)	// 和两个string对象比较s1 < s2效果一样
```

#### 目标字符串的大小由调用者指定

```c++
// 将largeStr 初始化成s1、一个空格和s2的连接
string largeStr = s1 + " " + s2;
```

同样的操作放到`ca1`和`ca2`上就会报错。表达式`ca1+ca2`试图将两个指针相加，这样的操作是非法的。

我们若想这样使用，则需要使用strcat函数和strcpy函数。若想要用这两个函数，还必须提供一个用于存放结果字符串的数组，该数组必须足够大以便容纳下结果字符串及末尾的空字符。

下述代码虽然可以解决，但是极其容易引发错误，如果我们计算错了largeStr的大小就会引发严重的错误

```c++
strcoy(largeStr, ca1);		// 将cal拷贝给LargeStr
strcat(largeStr, " ");		// 在largeStr末尾加上一个空格
strcat(largeStr, ca2);		// 在largestr末尾加上ca2
```

一个潜在的问题是，我们在估算largeStr所需要的空间时候不容易算准，而且largeStr所存的内容一旦改变，就必须重新检查其空间是否足够。

对大多数应用来说，使用标准库string要比使用C风格字符串更加安全、更加高效。

#### 练习

```c++
// 下述代码含义 结果为何
int main(){
    const char ca[] = {'h','e','l','l','o'};		// 定义C风格字符串
    const char *cp = ca;							// 指针cp指向ca的第一个元素
    while(*cp){										// 循环判断cp是否是有效值
        cout << *cp << endl;						// 输出cp的值
        ++cp;										// 指针移位
    }
}
/*
输出以下内容
h
e
l
l
o


x
*/
```

为什么两个指针相加没什么意义？

1. 指针相减代表的是两个指针间的距离，相加是为了得到什么？
2. 相加后的距离可能超出了内存的最大值或者指向某个不知道是什么东西的地址，可能导致越界
3. 指针和常量表达式相加减可以用于快速寻址，但是两个指针相加却可能会导致我们指向这两个指针范围外的地址。

### 与旧代码的接口

很多C++程序在标准库出现前就写好了，它们没用到string和vector类型。且，有些C++程序实际上是与C语言或者其他语言的接口程序，当然也无法使用C++标准库。

#### 混用string对象和C风格字符串

```c++
string s("Hello World!");
```

更常见的情况是，任何出现字符串字面值的地方都可以用以空字符结束的字符数组来替代

- 允许使用以空字符结束的字符数组来初始化string对象或者为string对象赋值
- 在string对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象(只能有一个)；在string对象的符号赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象。

如果程序的某处需要一个C风格字符串，无法直接用string对象来代替它。

不能用string对象直接初始化指向字符的指针。

为完成该功能，string专门提供一个名为c_str的成员函数

```c++
char *str = s;						// 错误 不能直接用string对象初始化char*
const char *str = s.c_str();		// 正确
```

c_str()返回的是一个C风格字符串。也就是说函数的返回结果是个指针，该指针指向一个以空字符结束的字符数组，而该数组所存的数据恰好与那个string对象的一样。结果指针的类型是const char*。

后续的操作改变了s的值就有可能让之前返回的数组(c_str())失去作用。也就是说像一个只能使用c_str()的返回值，最好是把他拷贝一遍。

#### 使用数组初始化vector对象

只需指明拷贝区域的首元素地址和尾元素地址就行

```c++
int int_arr[] = {0,1,2,3,4,5};
// ivec 有6个元素 粉笔额是int_arr中对应元素的副本
vector<int> ivec(begin(int_arr), end(int_arr));
// ivec与int_arr的元素数量相同 次序和值也完全相同
```

用于初始化vector对象的值也可能只是数组的一部分

```c++
// 拷贝三个元素 int_arr[1]到int_arr[3]
vector<int> subVec(int_arr + 1, int_arr + 4);
```

**事实上我们应该尽量使用标准库类型而不要使用数组**

使用指针和数组容易出错。现代的C++程序应该尽量用vector和迭代器，避免使用内置数组和指针；应该尽量用string，避免使用C风格的基于数组的字符串。

#### 练习

1. 用整型数组初始化一个vector对象

    ```c++
    int main(){
        int ia[] = {0,1,2,3,4,5};
        vector<int> iv(std::begin(ia), std::end(ia));
        // 验证
        for (int i : iv)
            cout << i;
        system("pause");
        return 0;
    }
    ```

2. 将含有整数元素的vector对象拷贝给一个整型数组

    看着网上一堆复制粘贴爷给整乐了，看来看去还不如一条[百度知道](https://zhidao.baidu.com/question/1047071626844744339.html)让我知道的多

    ```c++
    int main(){
        vector<int> ivec{0,1,2,3,4,5,100,213,234,63634};                    // 创建一个示例vector
        int ilist[ivec.size()];                                             // 使用vector的长度作为数组的长度
        int *p = ilist;                                                     // 指针p指向&ilist[0]
        // 创建一个迭代器i用于遍历vector对象ivec的每个值
        for (vector<int>::iterator i = ivec.begin();i != ivec.end();++i){
            *p = *i;            // 将迭代器i的值解引用赋给指针p
            ++p;                // 指针p的位置加1
        }

        // 验证 遍历数组ilist 输出ilist的所有内容 以空格分隔
        for(int i : ilist)
            cout << i << ' ';
        system("pause");
        return 0;
    }

    ```

## 多维数组

通常说的多维数组其实是数组的数组。严格的说C++没有多维数组。

```c++
int ia[3][4];		// 大小为3的数组 每个数组元素中有4个数组

int arr[10][30][40] = {0};	// 将所有元素初始化为0
// 大小为10的数组 每个数组中有30个数组 这30个数组中每个有40个数组
// 即 总大小为 10*30*40 = 12000 这12000个元素的值都是0
```

对于二维数组，通常把第一个维度称为行，第二个维度称为列

### 多维数组的初始化

示例

```c++
int ia[3][4] = {
	{0, 1, 2, 3},		// [0][0], [0][1], [0][2], [0][3]
	{4, 5, 6, 7},		// [1][0], [1][1], [1][2], [1][3]
	{8, 9, 10, 11}		// [2][0], [2][1], [2][2], [2][3]
};
```

内层嵌套的`{}`也可以不用，如下代码实现功能与上述完全一致

```c++
int ia[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11}
```

如下代码，初始化每个行的第一个元素。其余的元素被执行默认值初始化，如果省略`{}`那么效果就变成先初始化第一行元素，若有多的再初始化第二行，再有多就初始化第三行，再多就越界报错。

```c++
int ia[3][4] = {{0},{4},{8}};
```

### 多维数组的下标引用

可以用下标运算符来访问多维数组的元素,数组的每个维度对应一个下标运算符
```c++
ia[2][3] = arr[0][0][0];	// 将arr的首元素赋给ia的尾元素
int (&row)[4] = ia[1];		// 把row绑定到ia的第2维度的元素上--> 可以理解为&row引用的是一个长度为4的ia[1]
// [4]表示的是 ia[1]应该有的长度 如果没有 那么编译器就会报错
```

两层嵌套的for循环来处理多维数组的元素

```c++
constexpr size_t rowCnt = 3, colCnt = 4;		// 定义访问数组类型的常量 rowCnt colCnt
int ia[rowCnt][colCnt];		// 12个未初始化的元素
for (size_t i = 0; i != rowCnt; ++i){
    // 对于行内每一列
    for (size_t j = 0; j!= colCnt; ++j){
        // 将元素的位置索引作为它的值
        ia[i][j] = i* colCnt + j;
    }
}
```

###  使用范围for语句处理多维数组

C++11新增的范围for语句 所以也可以使用

```c++
int main(){
    constexpr size_t rowCnt = 3, colCnt = 4;        // 定义访问数组类型的常量 rowCnt colCnt
    int ia[rowCnt][colCnt];     // 12个未初始化的元素

    size_t cnt = 0;
    for (auto &row : ia)
        for (auto col : row)
            cout << col << endl;
    system("pause");
    return 0;
}
```

此处我们不知道应该是用什么类型来表示数组的类型，所以使用auto

这个循环中没有任何写操作，但是还是将外层的控制变量声明为引用类型，这是为了避免数组被自动转成指针。

假设不用引用类型，则循环如下形式

```c++
for (auto row : ia)
    for (auto col : row)
```

程序将会无法通过编译。像之前一样第一个循环遍历ia的所有元素，但这些元素实际上是大小为4的数组。因为row不是引用类型，所以编译器初始化row时候会自动将这些数组形式的元素(和其他类型的数组一样)转换成指向该数组内首元素的指针(`row`指向ia当前行的第一个元素)。这样得到的`row`的类型就是`int*`，显然到了里面的循环就不合法了。

**也就是说要用范围for语句处理多维数组，除了最内层的循环之外，其他外层所有循环的控制变量都应该用引用类型。**

### 指针和多维数组

当程序使用多维数组的名字时，也会自动将其转换成指向数组首元素的指针。

因为多维数组实际上是数组的数组，所以由多维数组名转换得到的指针实际上是指向第一个内层数组的指针

```c++
int ia[3][4];
int (*p)[4] = ia;	// p指向含有4个整数的数组
p = &ia[2];			// p指向ia的第2个维度 也就是指向ia的第2行
```

`*p`是个指针，指向一个维度是4的数组，数组中的元素是整数。因此，p就是指向含有4个整数的数组的指针。在其中，圆括号是必不可少的。

C++11的提出使得我们可以通过auto或decltype来避免在数组前加上一个指针类型。

```c++
// 输出ia中每个元素的值 每个内层数组各占一行
// p指向含有4个整数的数组
int ia[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};
for (auto p = ia;p != ia + 3; ++p){					// p的类型为int *[4] 是一个指向长度为4的数组的指针
	// q指向4个整数数组的首元素 也就是说 q指向一个整数
	for (auto q = *p;q != *p + 4; ++q)				// q的类型为int* 是一个指向int的指针
		cout << *q << ' ';
	cout << endl;
}
```

也可以使用标准库函数begin和end

```c++
int main(){
    constexpr size_t rowCnt = 3, colCnt = 4;        // 定义访问数组类型的常量 rowCnt colCnt
    int ia[rowCnt][colCnt];     // 12个未初始化的元素

    // 输出ia中每个元素的值 每个内层数组各占一行
    // p指向ia的第一个数组
    for (auto p = begin(ia); p != end(ia); ++p){
        // q指向内层数组的首元素
        for (auto q = begin(*p); q != end(*p); ++q)
            cout << *q << ' ';
        cout << endl;
    }
    system("pause");
    return 0;
}
```

在begin和end这一版本中，循环终止条件由end函数负责判断。虽然我们也能推断出p的类型是指向含有4个整数的数组的指针，q的类型是指向整数的指针，但是使用auto关键字我们就不用再去考虑这些类型到底是什么了。

### 类型别名简化多维数组的指针

使用类型别名能帮助我们读、写、理解一个指向多维数组的指针的工作更加简单。

详见 C++基础 ——> 处理类型 ——> 类型别名

```c++
int main(){
    constexpr size_t rowCnt = 3, colCnt = 4;        // 定义访问数组类型的常量 rowCnt colCnt
    int ia[rowCnt][colCnt];     // 12个未初始化的元素

    using int_array = int[4];       // 新标准下类型别名的声明
    typedef int int_array[4];       // 等价的typedef声明

    // 输出ia中每个元素的值 每个内层数组各占一行
    for (int_array *p = ia; p != ia + 3; ++p){
        for (int *q = *p; q != *p + 4; ++q)
            cout << *q << ' ';
        cout << endl;
    }
    system("pause");
    return 0;
}
```

程序将类型"4个整数组成的数组"命名为int_array，用类型名int_array定义外层循环的控制变量让程序显得简洁明了。

### 练习

1. 编写3个不同版本的程序，令其都可以输出ia的元素。版本1使用范围for语句管理迭代过程；版本2和版本3都用普通的for语句，其中版本2要求用下标运算符，版本3要求用指针。此外，在所有3个版本的程序中都要直接写出数据类型，而不能使用类型别名、auto关键字或者decltype关键字。

   1. ```c++
      // 版本1
      int main(){
          int ia[3][4] = {
              {0, 1, 2, 3},
              {4, 5, 6, 7},
              {8, 9, 10, 11}
          };
      
          // 版本1
          for (int (&i)[4] : ia){     // 已知ia每个维度长度为4 所以指定i引用长度为4的数组
              for (int a : i)         // 已知i引用的是一个长度为4的数组 所以用范围a遍历i的每个元素
                  cout << a;          // 输出a的值
              cout << endl;           // 换行
          }
      
          system("pause");
          return 0;
      }
      
      ```

   2. ```c++
      // 版本2
      int main(){
          int ia[3][4] = {
              {0, 1, 2, 3},
              {4, 5, 6, 7},
              {8, 9, 10, 11}
          };
      
          // 版本2
          for (size_t x = 0; x != 3; ++x){
              for (size_t y = 0; y != 4; ++y)
                  cout << ia[x][y] << ' ';
              cout << endl;
          }
      
          system("pause");
          return 0;
      }
      ```

   3. ```c++
      // 版本3
      int main(){
          int ia[3][4] = {
              {0, 1, 2, 3},
              {4, 5, 6, 7},
              {8, 9, 10, 11}
          };
      
          // 版本3
          for (int (*x)[4] = ia; x != ia + 3; ++x){       // 指针x指向一个长度为4的数组ia[0] x = ia[0] --> x --> ia{0,1,2,3}
              for (int *y = *x; y != *x + 4; ++y)         // 将x指针解引用获得ia[0]的地址 然后赋给指针y 随后移动y指针的位置
                  cout << *y << ' ';                      // 事实上ia[0]所在的地方的值也是ia[0][0] 移动y也就是移动ia[0][y]
              cout << endl;
          }
      
          system("pause");
          return 0;
      }
      ```

   版本3使用auto版本

   ```c++
       // 版本3
       for (auto x = ia; x != ia + 3; ++x){            // x指向一个长度为4的数组ia[0] x = ia[0]
           for (auto y = *x; y != *x + 4; ++y)         // 将x指针解引用获得ia[0]的地址 然后赋给y
               cout << *y << ' ';                      // 解引用y输出值
           cout << endl;
       }
   ```

   

